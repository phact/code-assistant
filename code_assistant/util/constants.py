starter_app = """
```python
from fasthtml.common import *

app = FastHTML()
rt = app.route


@rt('/')
def get():
    return Div('Hello, World!')

serve()
```
"""

small_fasthtml_context = """
## Objective: 
Build a FastHTML app. 

## FastHTML Basics:

FastHTML is a NEW python web application framework, NOT TO BE CONFUSED WITH FASTAPI.

Here's a very basic, fully functional hello world which we'll break down:

```python
from fasthtml.common import *

app = FastHTML()
rt = app.route


@rt('/')
def get():
    return Div('Hello, World!')

serve()
```

### Application Setup:

Initialize a FastHTML app using app = FastHTML(hdrs=(picolink, css)).
Define routes using a shorthand 


```
rt = app.route

@rt('/')
def get():
    ...
```

### HTMX

FastHTML uses htmx for dynamic content updates. Avoid backend redirects like RedirectResponse and frontend events like onclick. Use htmx instead.

### Function Naming and Routes:

To crate routes always define HTTP method functions with the name of the HTTP method (get, post) and
Use @app.route('/') to apply routes, handling HTTP GET requests for rendering pages.

Always create a route for the root path ('/') to serve the main page of the app.

```
rt = app.route

@rt('/')
def get():
    return Div('Hello, World!')
    ...

@rt('/other-endpoint')
def post():
    ...
```
    
or alternatively using the app.get, app.post decorators:

```
@app.post('/vehicle/')
def select_vehicle(choice: str):
    ...
```
### HTML Structure:

FastHTML uses FastTags (known as FTs) these are python objects for creating HTML elements (e.g., Div, Button, Span).
FTs live in fasthtml.common are imported using:

    from fasthtml.common import *

Always import * from fasthtml.common rather than doing individual imports

HTML attributes map to FTs attributes which can be set using named python arguments. For example, to set the class attribute of a Div element:

Div(cls='my-class')

You can nest FTs inside each other using positional python arguments in order to create complex HTML structures. 

Remember to include positional arguments (i.e. other FTs) before you include keyword arguments (i.e. attrs).
 
The following example is incorrect:

    return Div(cls='my-class', Div('inner div')) 

It will return following runtime error: `positional argument follows keyword argument`


    return Div(Div('inner div'), cls='my-class')

Error loading app fast_game: positional argument follows keyword argument (fast_game.py, line 35)

Use semantic elements like Nav, Header, Form, Section to organize content.
Ensure that children elements are passed as positional arguments to parent tags.

## Style and Script

You can include CSS and JS in your FastHTML app using the Style and Script FTs.

for example:

```python
style = Style('body { background-color: lightblue; }')
script = Script('alert("Hello, World!")')

app = FastHTML(hdrs=(style, script))
```

IMPORANT Style and Script take a string as their first argument, which is the content of the style or script tag.
and the scripts need to go in hdrs=(...) in the FastHTML constructor.

## Request Parameters

When you specify arguments to a route, FastHTML will search the request for values with the same name, and convert them to the correct type. 
IMPORTANT you must use type hints for these arguments.

In order, it searches:
 - The path parameters
 - The query parameters
 - The cookies
 - The headers
 - The session
 - Form data
 
There are also a few special arguments:
 - request (or any prefix like req): gets the raw Starlette Request object
 - session (or any prefix like sess): gets the session object
 - auth
 - htmx
 - app
In this section let’s quickly look at some of these in action.

### Path Parameters:
When passing path parameters to a route, use the same name as the parameter in the path and always use type hints.

For example, this route:
```
@app.post('/thing/{id}')
def select_vehicle(id: str): # NOTICE the type hint for id, this is required or the variable will be set to None
    ...
```

Will accept the request made by the HTML generated by this FT:

```
Button(cls='btn', hx_post=f'/thing/my_thing_id', hx_swap="none")
```

### Query Parameters:
When passing query parameters to a route, make sure your parameter names match and always use type hints.

For example, this route:
```
@app.post('/thing')
def select_vehicle(id: str): # NOTICE the type hint for id, this is required or the variable will be set to None
    ...
```

Will accept the request made by the HTML generated by this FT:

```
Button(cls='btn', hx_post=f'/thing_id?id=my_thing_id', hx_swap="none")
```

### Body Parameters:

For POST routes you can also use body parameters but you must use a Form in the html.

```
@app.post('/thing_id')
def select_vehicle(id: str): # NOTICE the type hint for id, this is required or the variable will be set to None
    ...
```

And the FTs would look like this:

```
Form(Input(id='id', type='text'), Button('Submit'), action='/thing_id', method='post')
```

The id attribute of the input tag(s) must match the parameter name(s) in the route.

### With checkboxes or radio buttons


```
@rt("/context")
async def get(option_one: str = None, option_two: str = None, option_three: str = None): # NOTICE the type hints these are required or the variables will be set to None
    if option_one == 'on':
        ...
```


```
    Form(
        Div(
            Label(
                "Option One",
                Input(
                    id="option_one",
                    name="option_one",
                    type="checkbox",
                    checked=False
                ),
                for_="option_one"
            ),
            Label(
                "Option Two",
                Input(
                    id="option_two",
                    name="option_two",
                    type="checkbox",
                    checked=True
                ),
                for_="option_two"
            ),
            ...
            ),
        ),
        hx_trigger="change", hx_encoding='multipart/form-data', hx_get='/context', hx_swap="none",
    ),
```


### Static Files:

FastHTML uses starlette's path syntax, and adds a `static` type which matches standard static file extensions.
This means that FastHTML will by default serve static files from the directory from which the app is run.


### Serving the Application:

Use serve() with no arguments to start the application server directly, without conditionals or arguments. 
serve is a function that can be imported from FastHTML.common. It does not take any arguments. It is not a method of the FastHTML class.

### Common Errors to Avoid:

Ensure all parentheses are properly matched.
Use cls= instead of _class= for applying CSS classes. Multiple classes can be assigned in a single argument cls="class1 class2"

Import necessary modules correctly and avoid redundancy in code.

Make sure to properly use " and ' in fstrings i.e. f"{dict['puppies']}" is correct. f'{dict['puppies']}' is incorrect.

Example app:

###
# Walkthough of an idiomatic fasthtml app
###

# This fasthtml app includes functionality from fastcore, starlette, fastlite, and fasthtml itself.
# Run with: `python adv_app.py`
# Importing * from `fasthtml.common` brings the key parts of all of these together.
# For simplicity, you can just `from fasthtml.common import *`:
#Some useful functions and classes in fasthtml.common include:
# -  Most HTML components including: 
#A, AX, Button, Card, Checkbox, Container, Div, Form, Grid, Group, H1, H2, Hidden, Input, Li, Main, Script, Style, Textarea, Title, Titled, Ul,
# - Some are FastHTML symbols:
#    Beforeware, fast_app, SortableJS, fill_form, picolink, serve,
#Other useful simbols for Fast HTML Apps include things from Starlette, Fastlite, fastcore, and the Python stdlib:
#    FileResponse, NotFoundError, RedirectResponse, database, patch, dataclass
from fasthtml.common import *
from hmac import compare_digest

# You can use any database you want; it'll be easier if you pick a lib that supports the MiniDataAPI spec.
# Here we are using SQLite, with the FastLite library, which supports the MiniDataAPI spec.
db = database('data/utodos.db')
# The `t` attribute is the table collection. The `todos` and `users` tables are not created if they don't exist.
# Instead, you can use the `create` method to create them if needed.
todos,users = db.t.todos,db.t.users
if todos not in db.t:
    # You can pass a dict, or kwargs, to most MiniDataAPI methods.
    users.create(dict(name=str, pwd=str), pk='name')
    todos.create(id=int, title=str, done=bool, name=str, details=str, priority=int, pk='id')
# Although you can just use dicts, it can be helpful to have types for your DB objects.
# The `dataclass` method creates that type, and stores it in the object, so it will use it for any returned items.
Todo,User = todos.dataclass(),users.dataclass()

# Any Starlette response class can be returned by a FastHTML route handler.
# In that case, FastHTML won't change it at all.
# Status code 303 is a redirect that can change POST to GET, so it's appropriate for a login page.
login_redir = RedirectResponse('/login', status_code=303)

# The `before` function is a *Beforeware* function. These are functions that run before a route handler is called.
def before(req, sess):
    # This sets the `auth` attribute in the request scope, and gets it from the session.
    # The session is a Starlette session, which is a dict-like object which is cryptographically signed,
    # so it can't be tampered with.
    # The `auth` key in the scope is automatically provided to any handler which requests it, and can not
    # be injected by the user using query params, cookies, etc, so it should be secure to use.
    auth = req.scope['auth'] = sess.get('auth', None)
    # If the session key is not there, it redirects to the login page.
    if not auth: return login_redir
    # `xtra` is part of the MiniDataAPI spec. It adds a filter to queries and DDL statements,
    # to ensure that the user can only see/edit their own todos.
    todos.xtra(name=auth)

markdown_js = \"\"\"
import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
import { proc_htmx} from "https://cdn.jsdelivr.net/gh/answerdotai/fasthtml-js/fasthtml.js";
proc_htmx('.markdown', e => e.innerHTML = marked.parse(e.textContent));
\"\"\"

# We will use this in our `exception_handlers` dict
def _not_found(req, exc): return Titled('Oh no!', Div('We could not find that page :('))

# To create a Beforeware object, we pass the function itself, and optionally a list of regexes to skip.
bware = Beforeware(before, skip=[r'/favicon\.ico', r'/static/.*', r'.*\.css', '/login'])
# The `FastHTML` class is a subclass of `Starlette`, so you can use any parameters that `Starlette` accepts.
# In addition, you can add your Beforeware here, and any headers you want included in HTML responses.
# FastHTML includes the "HTMX" and "Surreal" libraries in headers, unless you pass `default_hdrs=False`.
app = FastHTML(before=bware,
               # These are the same as Starlette exception_handlers, except they also support `FT` results
               exception_handlers={404: _not_found},
               # PicoCSS is a particularly simple CSS framework, with some basic integration built in to FastHTML.
               # `picolink` is pre-defined with the header for the PicoCSS stylesheet.
               # You can use any CSS framework you want, or none at all.
               hdrs=(picolink,
                     # `Style` is an `FT` object, which are 3-element lists consisting of:
                     # (tag_name, children_list, attrs_dict).
                     # FastHTML composes them from trees and auto-converts them to HTML when needed.
                     # You can also use plain HTML strings in handlers and headers,
                     # which will be auto-escaped, unless you use `NotStr(...string...)`.
                     Style(':root { --pico-font-size: 100%; }'),
                     # Have a look at fasthtml/js.py to see how these Javascript libraries are added to FastHTML.
                     # They are only 5-10 lines of code each, and you can add your own too.
                     SortableJS('.sortable'),
                     # MarkdownJS is actually provided as part of FastHTML, but we've included the js code here
                     # so that you can see how it works.
                     Script(markdown_js, type='module'))
                )
# We add `rt` as a shortcut for `app.route`, which is what we'll use to decorate our route handlers.
# When using `app.route` (or this shortcut), the only required argument is the path.
# The name of the decorated function (eg `get`, `post`, etc) is used as the HTTP verb for the handler.
rt = app.route

# For instance, this function handles GET requests to the `/login` path.
@rt("/login")
def get():
    # This creates a form with two input fields, and a submit button.
    # All of these components are `FT` objects. All HTML tags are provided in this form by FastHTML.
    # If you want other custom tags (e.g. `MyTag`), they can be auto-generated by e.g
    # `from fasthtml.common import MyTag`.
    # Alternatively, manually call e.g `ft(tag_name, *children, **attrs)`.
    frm = Form(
        # Tags with a `name` attr will have `name` auto-set to the same as `id` if not provided
        Input(id='name', placeholder='Name'),
        Input(id='pwd', type='password', placeholder='Password'),
        Button('login'),
        action='/login', method='post')
    # If a user visits the URL directly, FastHTML auto-generates a full HTML page.
    # However, if the URL is accessed by HTMX, then one HTML partial is created for each element of the tuple.
    # To avoid this auto-generation of a full page, return a `HTML` object, or a Starlette `Response`.
    # `Titled` returns a tuple of a `Title` with the first arg and a `Container` with the rest.
    # See the comments for `Title` later for details.
    return Titled("Login", frm)

# Handlers are passed whatever information they "request" in the URL, as keyword arguments.
# Dataclasses, dicts, namedtuples, TypedDicts, and custom classes are automatically instantiated
# from form data.
# In this case, the `Login` class is a dataclass, so the handler will be passed `name` and `pwd`.
@dataclass
class Login: name:str; pwd:str

# This handler is called when a POST request is made to the `/login` path.
# The `login` argument is an instance of the `Login` class, which has been auto-instantiated from the form data.
# There are a number of special parameter names, which will be passed useful information about the request:
# `session`: the Starlette session; `request`: the Starlette request; `auth`: the value of `scope['auth']`,
# `htmx`: the HTMX headers, if any; `app`: the FastHTML app object.
# You can also pass any string prefix of `request` or `session`.
@rt("/login")
def post(login:Login, sess):
    if not login.name or not login.pwd: return login_redir
    # Indexing into a MiniDataAPI table queries by primary key, which is `name` here.
    # It returns a dataclass object, if `dataclass()` has been called at some point, or a dict otherwise.
    try: u = users[login.name]
    # If the primary key does not exist, the method raises a `NotFoundError`.
    # Here we use this to just generate a user -- in practice you'd probably to redirect to a signup page.
    except NotFoundError: u = users.insert(login)
    # This compares the passwords using a constant time string comparison
    # https://sqreen.github.io/DevelopersSecurityBestPractices/timing-attack/python
    if not compare_digest(u.pwd.encode("utf-8"), login.pwd.encode("utf-8")): return login_redir
    # Because the session is signed, we can securely add information to it. It's stored in the browser cookies.
    # If you don't pass a secret signing key to `FastHTML`, it will auto-generate one and store it in a file `./sesskey`.
    sess['auth'] = u.name
    return RedirectResponse('/', status_code=303)

# Instead of using `app.route` (or the `rt` shortcut), you can also use `app.get`, `app.post`, etc.
# In this case, the function name is not used to determine the HTTP verb.
@app.get("/logout")
def logout(sess):
    del sess['auth']
    return login_redir

# FastHTML uses Starlette's path syntax, and adds a `static` type which matches standard static file extensions.
# You can define your own regex path specifiers -- for instance this is how `static` is defined in FastHTML
# `reg_re_param("static", "ico|gif|jpg|jpeg|webm|css|js|woff|png|svg|mp4|webp|ttf|otf|eot|woff2|txt|xml|html")`
# In this app, we only actually have one static file, which is `favicon.ico`. But it would also be needed if
# we were referencing images, CSS/JS files, etc.
# Note, this function is unnecessary, as the `fast_app()` call already includes this functionality.
# However, it's included here to show how you can define your own static file handler.
@rt("/{fname:path}.{ext:static}")
async def get(fname:str, ext:str): return FileResponse(f'{fname}.{ext}')

# The `patch` decorator, which is defined in `fastcore`, adds a method to an existing class.
# Here we are adding a method to the `Todo` class, which is returned by the `todos` table.
# The `__ft__` method is a special method that FastHTML uses to convert the object into an `FT` object,
# so that it can be composed into an FT tree, and later rendered into HTML.
@patch
def __ft__(self:Todo):
    # Some FastHTML tags have an 'X' suffix, which means they're "extended" in some way.
    # For instance, here `AX` is an extended `A` tag, which takes 3 positional arguments:
    # `(text, hx_get, target_id)`.
    # All underscores in FT attrs are replaced with hyphens, so this will create an `hx-get` attr,
    # which HTMX uses to trigger a GET request.
    # Generally, most of your route handlers in practice (as in this demo app) are likely to be HTMX handlers.
    # For instance, for this demo, we only have two full-page handlers: the '/login' and '/' GET handlers.
    show = AX(self.title, f'/todos/{self.id}', 'current-todo')
    edit = AX('edit',     f'/edit/{self.id}' , 'current-todo')
    dt = '✅ ' if self.done else ''
    # FastHTML provides some shortcuts. For instance, `Hidden` is defined as simply:
    # `return Input(type="hidden", value=value, **kwargs)`
    cts = (dt, show, ' | ', edit, Hidden(id="id", value=self.id), Hidden(id="priority", value="0"))
    # Any FT object can take a list of children as positional args, and a dict of attrs as keyword args.
    return Li(*cts, id=f'todo-{self.id}')

# This is the handler for the main todo list application.
# By including the `auth` parameter, it gets passed the current username, for displaying in the title.
@rt("/")
def get(auth):
    title = f"{auth}'s Todo list"
    top = Grid(H1(title), Div(A('logout', href='/logout'), style='text-align: right'))
    # We don't normally need separate "screens" for adding or editing data. Here for instance,
    # we're using an `hx-post` to add a new todo, which is added to the start of the list (using 'afterbegin').
    new_inp = Input(id="new-title", name="title", placeholder="New Todo")
    add = Form(Group(new_inp, Button("Add")),
               hx_post="/", target_id='todo-list', hx_swap="afterbegin")
    # In the MiniDataAPI spec, treating a table as a callable (i.e with `todos(...)` here) queries the table.
    # Because we called `xtra` in our Beforeware, this queries the todos for the current user only.
    # We can include the todo objects directly as children of the `Form`, because the `Todo` class has `__ft__` defined.
    # This is automatically called by FastHTML to convert the `Todo` objects into `FT` objects when needed.
    # The reason we put the todo list inside a form is so that we can use the 'sortable' js library to reorder them.
    # That library calls the js `end` event when dragging is complete, so our trigger here causes our `/reorder`
    # handler to be called.
    frm = Form(*todos(order_by='priority'),
               id='todo-list', cls='sortable', hx_post="/reorder", hx_trigger="end")
    # We create an empty 'current-todo' Div at the bottom of our page, as a target for the details and editing views.
    card = Card(Ul(frm), header=add, footer=Div(id='current-todo'))
    # PicoCSS uses `<Main class='container'>` page content; `Container` is a tiny function that generates that.
    # A handler can return either a single `FT` object or string, or a tuple of them.
    # In the case of a tuple, the stringified objects are concatenated and returned to the browser.
    # The `Title` tag has a special purpose: it sets the title of the page.
    return Title(title), Container(top, card)

# This is the handler for the reordering of todos.
# It's a POST request, which is used by the 'sortable' js library.
# Because the todo list form created earlier included hidden inputs with the todo IDs,
# they are passed as form data. By using a parameter called (e.g) "id", FastHTML will try to find
# something suitable in the request with this name. In order, it searches as follows:
# path; query; cookies; headers; session keys; form data.
# Although all these are provided in the request as strings, FastHTML will use your parameter's type
# annotation to try to cast the value to the requested type.
# In the case of form data, there can be multiple values with the same key. So in this case,
# the parameter is a list of ints.
@rt("/reorder")
def post(id:list[int]):
    for i,id_ in enumerate(id): todos.update({'priority':i}, id_)
    # HTMX by default replaces the inner HTML of the calling element, which in this case is the todo list form.
    # Therefore, we return the list of todos, now in the correct order, which will be auto-converted to FT for us.
    # In this case, it's not strictly necessary, because sortable.js has already reorder the DOM elements.
    # However, by returning the updated data, we can be assured that there aren't sync issues between the DOM
    # and the server.
    return tuple(todos(order_by='priority'))

# Refactoring components in FastHTML is as simple as creating Python functions.
# The `clr_details` function creates a Div with specific HTMX attributes.
# `hx_swap_oob='innerHTML'` tells HTMX to swap the inner HTML of the target element out-of-band,
# meaning it will update this element regardless of where the HTMX request originated from.
def clr_details(): return Div(hx_swap_oob='innerHTML', id='current-todo')

# This route handler uses a path parameter `{id}` which is automatically parsed and passed as an int.
@rt("/todos/{id}")
def delete(id:int):
    # The `delete` method is part of the MiniDataAPI spec, removing the item with the given primary key.
    todos.delete(id)
    # Returning `clr_details()` ensures the details view is cleared after deletion,
    # leveraging HTMX's out-of-band swap feature.
    # Note that we are not returning *any* FT component that doesn't have an "OOB" swap, so the target element
    # inner HTML is simply deleted. That's why the deleted todo is removed from the list.
    return clr_details()

@rt("/edit/{id}")
async def get(id:int):
    # The `hx_put` attribute tells HTMX to send a PUT request when the form is submitted.
    # `target_id` specifies which element will be updated with the server's response.
    res = Form(Group(Input(id="title"), Button("Save")),
        Hidden(id="id"), Checkbox(id="done", label='Done'),
        Textarea(id="details", name="details", rows=10),
        hx_put="/", target_id=f'todo-{id}', id="edit")
    # `fill_form` populates the form with existing todo data, and returns the result.
    # Indexing into a table (`todos`) queries by primary key, which is `id` here. It also includes
    # `xtra`, so this will only return the id if it belongs to the current user.
    return fill_form(res, todos[id])

@rt("/")
async def put(todo: Todo):
    # `update` is part of the MiniDataAPI spec.
    # Note that the updated todo is returned. By returning the updated todo, we can update the list directly.
    # Because we return a tuple with `clr_details()`, the details view is also cleared.
    return todos.update(todo), clr_details()

@rt("/")
async def post(todo:Todo):
    # `hx_swap_oob='true'` tells HTMX to perform an out-of-band swap, updating this element wherever it appears.
    # This is used to clear the input field after adding the new todo.
    new_inp =  Input(id="new-title", name="title", placeholder="New Todo", hx_swap_oob='true')
    # `insert` returns the inserted todo, which is appended to the start of the list, because we used
    # `hx_swap='afterbegin'` when creating the todo list form.
    return todos.insert(todo), new_inp

@rt("/todos/{id}")
async def get(id:int):
    todo = todos[id]
    # `hx_swap` determines how the update should occur. We use "outerHTML" to replace the entire todo `Li` element.
    btn = Button('delete', hx_delete=f'/todos/{todo.id}',
                 target_id=f'todo-{todo.id}', hx_swap="outerHTML")
    # The "markdown" class is used here because that's the CSS selector we used in the JS earlier.
    # Therefore this will trigger the JS to parse the markdown in the details field.
    # Because `class` is a reserved keyword in Python, we use `cls` instead, which FastHTML auto-converts.
    return Div(H2(todo.title), Div(todo.details, cls="markdown"), btn)

serve()
"""

big_fasthtml_context = """
<project title="FastHTML" summary='FastHTML is a python library which brings together Starlette, Uvicorn, HTMX, and fastcore&#39;s `FT` "FastTags" into a library for creating server-rendered hypermedia applications. The `FastHTML` class itself inherits from `Starlette`, and adds decorator-based routing with many additions, Beforeware, automatic `FT` to HTML rendering, and much more. Although parts of its API are inspired by FastAPI, it is *not* compatible with FastAPI syntax and is not targeted at creating API services. FastHTML includes support for Pico CSS and the fastlite sqlite library, although using both are optional; sqlite can be used directly or via the fastsql library, and any CSS framework can be used. FastHTML is compatible with web components and any vanilla JS library, but not with React, Vue, or Svelte. Support for the Surreal and css-scope-inline libraries are also included, but both are optional.'>
  <docs>
    <doc title="FastHTML quick start" info="A brief overview of many FastHTML features"># Web Devs Quickstart



&lt;div&gt;

&gt; **Note**
&gt;
&gt; We’re going to be adding more to this document, so check back
&gt; frequently for updates.

&lt;/div&gt;

## Installation

``` bash
pip install python-fasthtml
```

## A Minimal Application

A minimal FastHTML application looks something like this:

&lt;div class=&quot;code-with-filename&quot;&gt;

**main.py**

``` python
from fasthtml.common import *

app, rt = fast_app()

@rt(&quot;/&quot;)
def get():
    return Titled(&quot;FastHTML&quot;, P(&quot;Let&#x27;s do this!&quot;))

serve()
```

&lt;/div&gt;

Line 1  
We import what we need for rapid development! A carefully-curated set of
FastHTML functions and other Python objects is brought into our global
namespace for convenience.

Line 3  
We instantiate a FastHTML app with the `fast_app()` utility function.
This provides a number of really useful defaults that we’ll take
advantage of later in the tutorial.

Line 5  
We use the `rt()` decorator to tell FastHTML what to return when a user
visits `/` in their browser.

Line 6  
We connect this route to HTTP GET requests by defining a view function
called `get()`.

Line 7  
A tree of Python function calls that return all the HTML required to
write a properly formed web page. You’ll soon see the power of this
approach.

Line 9  
The `serve()` utility configures and runs FastHTML using a library
called `uvicorn`.

Run the code:

``` bash
python main.py
```

The terminal will look like this:

``` bash
INFO:     Uvicorn running on http://0.0.0.0:5001 (Press CTRL+C to quit)
INFO:     Started reloader process [58058] using WatchFiles
INFO:     Started server process [58060]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

Confirm FastHTML is running by opening your web browser to
[127.0.0.1:5001](http://127.0.0.1:5001). You should see something like
the image below:

![](quickstart-web-dev/quickstart-fasthtml.png)

&lt;div&gt;

&gt; **Note**
&gt;
&gt; While some linters and developers will complain about the wildcard
&gt; import, it is by design here and perfectly safe. FastHTML is very
&gt; deliberate about the objects it exports in `fasthtml.common`. If it
&gt; bothers you, you can import the objects you need individually, though
&gt; it will make the code more verbose and less readable.
&gt;
&gt; If you want to learn more about how FastHTML handles imports, we cover
&gt; that [here](https://docs.fastht.ml/explains/faq.html#why-use-import).

&lt;/div&gt;

## A Minimal Charting Application

The
[`Script`](https://AnswerDotAI.github.io/fasthtml/api/xtend.html#script)
function allows you to include JavaScript. You can use Python to
generate parts of your JS or JSON like this:

``` python
import json
from fasthtml.common import * 

app, rt = fast_app(hdrs=(Script(src=&quot;https://cdn.plot.ly/plotly-2.32.0.min.js&quot;),))

data = json.dumps({
    &quot;data&quot;: [{&quot;x&quot;: [1, 2, 3, 4],&quot;type&quot;: &quot;scatter&quot;},
            {&quot;x&quot;: [1, 2, 3, 4],&quot;y&quot;: [16, 5, 11, 9],&quot;type&quot;: &quot;scatter&quot;}],
    &quot;title&quot;: &quot;Plotly chart in FastHTML &quot;,
    &quot;description&quot;: &quot;This is a demo dashboard&quot;,
    &quot;type&quot;: &quot;scatter&quot;
})


@rt(&quot;/&quot;)
def get():
  return Titled(&quot;Chart Demo&quot;, Div(id=&quot;myDiv&quot;),
    Script(f&quot;var data = {data}; Plotly.newPlot(&#x27;myDiv&#x27;, data);&quot;))

serve()
```

## Debug Mode

When we can’t figure out a bug in FastHTML, we can run it in `DEBUG`
mode. When an error is thrown, the error screen is displayed in the
browser. This error setting should never be used in a deployed app.

``` python
from fasthtml.common import *

app, rt = fast_app(debug=True)

@rt(&quot;/&quot;)
def get():
    1/0
    return Titled(&quot;FastHTML Error!&quot;, P(&quot;Let&#x27;s error!&quot;))

serve()
```

Line 3  
`debug=True` sets debug mode on.

Line 7  
Python throws an error when it tries to divide an integer by zero.

## Routing

FastHTML builds upon FastAPI’s friendly decorator pattern for specifying
URLs, with extra features:

&lt;div class=&quot;code-with-filename&quot;&gt;

**main.py**

``` python
from fasthtml.common import * 

app, rt = fast_app()

@rt(&quot;/&quot;)
def get():
  return Titled(&quot;FastHTML&quot;, P(&quot;Let&#x27;s do this!&quot;))

@rt(&quot;/hello&quot;)
def get():
  return Titled(&quot;Hello, world!&quot;)

serve()
```

&lt;/div&gt;

Line 5  
The “/” URL on line 5 is the home of a project. This would be accessed
at [127.0.0.1:5001](http://127.0.0.1:5001).

Line 9  
“/hello” URL on line 9 will be found by the project if the user visits
[127.0.0.1:5001/hello](http://127.0.0.1:5001/hello).

&lt;div&gt;

&gt; **Tip**
&gt;
&gt; It looks like `get()` is being defined twice, but that’s not the case.
&gt; Each function decorated with `rt` is totally separate, and is injected
&gt; into the router. We’re not calling them in the module’s namespace
&gt; (`locals()`). Rather, we’re loading them into the routing mechanism
&gt; using the `rt` decorator.

&lt;/div&gt;

You can do more! Read on to learn what we can do to make parts of the
URL dynamic.

## Variables in URLs

You can add variable sections to a URL by marking them with
`{variable_name}`. Your function then receives the `{variable_name}` as
a keyword argument, but only if it is the correct type. Here’s an
example:

&lt;div class=&quot;code-with-filename&quot;&gt;

**main.py**

``` python
from fasthtml.common import * 

app, rt = fast_app()

@rt(&quot;/{name}/{age}&quot;)
def get(name: str, age: int):
  return Titled(f&quot;Hello {name.title()}, age {age}&quot;)

serve()
```

&lt;/div&gt;

Line 5  
We specify two variable names, `name` and `age`.

Line 6  
We define two function arguments named identically to the variables. You
will note that we specify the Python types to be passed.

Line 7  
We use these functions in our project.

Try it out by going to this address:
[127.0.0.1:5001/uma/5](http://127.0.0.1:5001/uma/5). You should get a
page that says,

&gt; “Hello Uma, age 5”.

### What happens if we enter incorrect data?

The [127.0.0.1:5001/uma/5](http://127.0.0.1:5001/uma/5) URL works
because `5` is an integer. If we enter something that is not, such as
[127.0.0.1:5001/uma/five](http://127.0.0.1:5001/uma/five), then FastHTML
will return an error instead of a web page.

&lt;div&gt;

&gt; **FastHTML URL routing supports more complex types**
&gt;
&gt; The two examples we provide here use Python’s built-in `str` and `int`
&gt; types, but you can use your own types, including more complex ones
&gt; such as those defined by libraries like
&gt; [attrs](https://pypi.org/project/attrs/),
&gt; [pydantic](https://pypi.org/project/pydantic/), and even
&gt; [sqlmodel](https://pypi.org/project/sqlmodel/).

&lt;/div&gt;

## HTTP Methods

FastHTML matches function names to HTTP methods. So far the URL routes
we’ve defined have been for HTTP GET methods, the most common method for
web pages.

Form submissions often are sent as HTTP POST. When dealing with more
dynamic web page designs, also known as Single Page Apps (SPA for
short), the need can arise for other methods such as HTTP PUT and HTTP
DELETE. The way FastHTML handles this is by changing the function name.

&lt;div class=&quot;code-with-filename&quot;&gt;

**main.py**

``` python
from fasthtml.common import * 

app, rt = fast_app()

@rt(&quot;/&quot;)  
def get():
  return Titled(&quot;HTTP GET&quot;, P(&quot;Handle GET&quot;))

@rt(&quot;/&quot;)  
def post():
  return Titled(&quot;HTTP POST&quot;, P(&quot;Handle POST&quot;))

serve()
```

&lt;/div&gt;

Line 6  
On line 6 because the `get()` function name is used, this will handle
HTTP GETs going to the `/` URI.

Line 10  
On line 10 because the `post()` function name is used, this will handle
HTTP POSTs going to the `/` URI.

## CSS Files and Inline Styles

Here we modify default headers to demonstrate how to use the [Sakura CSS
microframework](https://github.com/oxalorg/sakura) instead of FastHTML’s
default of Pico CSS.

&lt;div class=&quot;code-with-filename&quot;&gt;

**main.py**

``` python
from fasthtml.common import * 

app, rt = fast_app(
    pico=False,
    hdrs=(
        Link(rel=&#x27;stylesheet&#x27;, href=&#x27;assets/normalize.min.css&#x27;, type=&#x27;text/css&#x27;),
        Link(rel=&#x27;stylesheet&#x27;, href=&#x27;assets/sakura.css&#x27;, type=&#x27;text/css&#x27;),
        Style(&quot;p {color: red;}&quot;)
))

@app.get(&quot;/&quot;)
def home():
    return Titled(&quot;FastHTML&quot;,
        P(&quot;Let&#x27;s do this!&quot;),
    )

serve()
```

&lt;/div&gt;

Line 4  
By setting `pico` to `False`, FastHTML will not include `pico.min.css`.

Line 7  
This will generate an HTML `&lt;link&gt;` tag for sourcing the css for Sakura.

Line 8  
If you want an inline styles, the `Style()` function will put the result
into the HTML.

## Other Static Media File Locations

As you saw,
[`Script`](https://AnswerDotAI.github.io/fasthtml/api/xtend.html#script)
and `Link` are specific to the most common static media use cases in web
apps: including JavaScript, CSS, and images. But it also works with
videos and other static media files. The default behavior is to look for
these files in the root directory - typically we don’t do anything
special to include them.

FastHTML also allows us to define a route that uses `FileResponse` to
serve the file at a specified path. This is useful for serving images,
videos, and other media files from a different directory without having
to change the paths of many files. So if we move the directory
containing the media files, we only need to change the path in one
place. In the example below, we call images from a directory called
`public`.

``` python
@rt(&quot;/{fname:path}.{ext:static}&quot;)
async def get(fname:str, ext:str): 
    return FileResponse(f&#x27;public/{fname}.{ext}&#x27;)
```

## Rendering Markdown

``` python
from fasthtml.common import *

hdrs = (MarkdownJS(), HighlightJS(langs=[&#x27;python&#x27;, &#x27;javascript&#x27;, &#x27;html&#x27;, &#x27;css&#x27;]), )

app, rt = fast_app(hdrs=hdrs)

content = &quot;&quot;&quot;
Here are some _markdown_ elements.

- This is a list item
- This is another list item
- And this is a third list item

**Fenced code blocks work here.**
&quot;&quot;&quot;

@rt(&#x27;/&#x27;)
def get(req):
    return Titled(&quot;Markdown rendering example&quot;, Div(content,cls=&quot;marked&quot;))

serve()
```

## Code highlighting

Here’s how to highlight code without any markdown configuration.

``` python
from fasthtml.common import *

# Add the HighlightJS built-in header
hdrs = (HighlightJS(langs=[&#x27;python&#x27;, &#x27;javascript&#x27;, &#x27;html&#x27;, &#x27;css&#x27;]),)

app, rt = fast_app(hdrs=hdrs)

code_example = &quot;&quot;&quot;
import datetime
import time

for i in range(10):
    print(f&quot;{datetime.datetime.now()}&quot;)
    time.sleep(1)
&quot;&quot;&quot;

@rt(&#x27;/&#x27;)
def get(req):
    return Titled(&quot;Markdown rendering example&quot;,
        Div(
            # The code example needs to be surrounded by
            # Pre &amp; Code elements
            Pre(Code(code_example))
    ))

serve()
```

## Defining new `ft` components

We can build our own `ft` components and combine them with other
components. The simplest method is defining them as a function.

``` python
def hero(title, statement):
    return Div(H1(title),P(statement), cls=&quot;hero&quot;)

# usage example
Main(
    hero(&quot;Hello World&quot;, &quot;This is a hero statement&quot;)
)
```

``` html
&lt;main&gt;
  &lt;div class=&quot;hero&quot;&gt;
    &lt;h1&gt;Hello World&lt;/h1&gt;
    &lt;p&gt;This is a hero statement&lt;/p&gt;
  &lt;/div&gt;
&lt;/main&gt;
```

### Pass through components

For when we need to define a new component that allows zero-to-many
components to be nested within them, we lean on Python’s `*args` and
`**kwargs` mechanism. Useful for creating page layout controls.

``` python
def layout(*args, **kwargs):
    &quot;&quot;&quot;Dashboard layout for all our dashboard views&quot;&quot;&quot;
    return Main(
        H1(&quot;Dashboard&quot;),
        Div(*args, **kwargs),
        cls=&quot;dashboard&quot;,
    )

# usage example
layout(
    Ul(*[Li(o) for o in range(3)]),
    P(&quot;Some content&quot;, cls=&quot;description&quot;),
)
```

``` html
&lt;main class=&quot;dashboard&quot;&gt;
  &lt;h1&gt;Dashboard&lt;/h1&gt;
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li&gt;0&lt;/li&gt;
      &lt;li&gt;1&lt;/li&gt;
      &lt;li&gt;2&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p class=&quot;description&quot;&gt;Some content&lt;/p&gt;
  &lt;/div&gt;
&lt;/main&gt;
```

### Dataclasses as ft components

While functions are easy to read, for more complex components some might
find it easier to use a dataclass.

``` python
from dataclasses import dataclass

@dataclass
class Hero:
    title: str
    statement: str
    
    def __ft__(self):
        &quot;&quot;&quot; The __ft__ method renders the dataclass at runtime.&quot;&quot;&quot;
        return Div(H1(self.title),P(self.statement), cls=&quot;hero&quot;)
    
# usage example
Main(
    Hero(&quot;Hello World&quot;, &quot;This is a hero statement&quot;)
)
```

``` html
&lt;main&gt;
  &lt;div class=&quot;hero&quot;&gt;
    &lt;h1&gt;Hello World&lt;/h1&gt;
    &lt;p&gt;This is a hero statement&lt;/p&gt;
  &lt;/div&gt;
&lt;/main&gt;
```

## Testing views in notebooks

Because of the ASGI event loop it is currently impossible to run
FastHTML inside a notebook. However, we can still test the output of our
views. To do this, we leverage Starlette, an ASGI toolkit that FastHTML
uses.

``` python
# First we instantiate our app, in this case we remove the
# default headers to reduce the size of the output.
app, rt = fast_app(default_hdrs=False)

# Setting up the Starlette test client
from starlette.testclient import TestClient
client = TestClient(app)

# Usage example
@rt(&quot;/&quot;)
def get():
    return Titled(&quot;FastHTML is awesome&quot;, 
        P(&quot;The fastest way to create web apps in Python&quot;))

print(client.get(&quot;/&quot;).text)
```

    &lt;!doctype html&gt;

    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;FastHTML is awesome&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
    &lt;main class=&quot;container&quot;&gt;
      &lt;h1&gt;FastHTML is awesome&lt;/h1&gt;
      &lt;p&gt;The fastest way to create web apps in Python&lt;/p&gt;
    &lt;/main&gt;
      &lt;/body&gt;
    &lt;/html&gt;

## Strings and conversion order

The general rules for rendering are: - `__ft__` method will be called
(for default components like `P`, `H2`, etc. or if you define your own
components) - If you pass a string, it will be escaped - On other python
objects, `str()` will be called

As a consequence, if you want to include plain HTML tags directly into
e.g. a `Div()` they will get escaped by default (as a security measure
to avoid code injections). This can be avoided by using `NotStr()`, a
convenient way to reuse python code that returns already HTML. If you
use pandas, you can use `pandas.DataFrame.to_html()` to get a nice
table. To include the output a FastHTML, wrap it in `NotStr()`, like
`Div(NotStr(df.to_html()))`.

Above we saw how a dataclass behaves with the `__ft__` method defined.
On a plain dataclass, `str()` will be called (but not escaped).

``` python
from dataclasses import dataclass

@dataclass
class Hero:
    title: str
    statement: str
        
# rendering the dataclass with the default method
Main(
    Hero(&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;, &quot;This is a hero statement&quot;)
)
```

``` html
&lt;main&gt;Hero(title=&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;, statement=&#x27;This is a hero statement&#x27;)&lt;/main&gt;
```

``` python
# This will display the HTML as text on your page
Div(&quot;Let&#x27;s include some HTML here: &lt;div&gt;Some HTML&lt;/div&gt;&quot;)
```

``` html
&lt;div&gt;Let&amp;#x27;s include some HTML here: &amp;lt;div&amp;gt;Some HTML&amp;lt;/div&amp;gt;&lt;/div&gt;
```

``` python
# Keep the string untouched, will be rendered on the page
Div(NotStr(&quot;&lt;div&gt;&lt;h1&gt;Some HTML&lt;/h1&gt;&lt;/div&gt;&quot;))
```

``` html
&lt;div&gt;&lt;div&gt;&lt;h1&gt;Some HTML&lt;/h1&gt;&lt;/div&gt;&lt;/div&gt;
```

## Custom exception handlers

FastHTML allows customization of exception handlers, but does so
gracefully. What this means is by default it includes all the `&lt;html&gt;`
tags needed to display attractive content. Try it out!

``` python
from fasthtml.common import *

def not_found(req, exc): return Titled(&quot;404: I don&#x27;t exist!&quot;)

exception_handlers = {404: not_found}

app, rt = fast_app(exception_handlers=exception_handlers)

@rt(&#x27;/&#x27;)
def get():
    return (Titled(&quot;Home page&quot;, P(A(href=&quot;/oops&quot;)(&quot;Click to generate 404 error&quot;))))

serve()
```

We can also use lambda to make things more terse:

``` python
from fasthtml.common import *

exception_handlers={
    404: lambda req, exc: Titled(&quot;404: I don&#x27;t exist!&quot;),
    418: lambda req, exc: Titled(&quot;418: I&#x27;m a teapot!&quot;)
}

app, rt = fast_app(exception_handlers=exception_handlers)

@rt(&#x27;/&#x27;)
def get():
    return (Titled(&quot;Home page&quot;, P(A(href=&quot;/oops&quot;)(&quot;Click to generate 404 error&quot;))))

serve()
```

## Cookies

We can set cookies using the `cookie()` function. In our example, we’ll
create a `timestamp` cookie.

``` python
from datetime import datetime
from IPython.display import HTML
```

``` python
@rt(&quot;/settimestamp&quot;)
def get(req):
    now = datetime.now()
    return P(f&#x27;Set to {now}&#x27;), cookie(&#x27;now&#x27;, datetime.now())

HTML(client.get(&#x27;/settimestamp&#x27;).text)
```

&lt;!doctype html&gt;
&amp;#10;&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;FastHTML page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
Set to 2024-08-07 09:07:47.535449
  &lt;/body&gt;
&lt;/html&gt;

Now let’s get it back using the same name for our parameter as the
cookie name.

``` python
@rt(&#x27;/gettimestamp&#x27;)
def get(now:date): return f&#x27;Cookie was set at time {now.time()}&#x27;

client.get(&#x27;/gettimestamp&#x27;).text
```

    &#x27;Cookie was set at time 09:07:47.535456&#x27;

## Sessions

For convenience and security, FastHTML has a mechanism for storing small
amounts of data in the user’s browser. We can do this by adding a
`session` argument to routes. FastHTML sessions are Python dictionaries,
and we can leverage to our benefit. The example below shows how to
concisely set and get sessions.

``` python
@rt(&#x27;/adder/{num}&#x27;)
def get(session, num: int):
    session.setdefault(&#x27;sum&#x27;, 0)
    session[&#x27;sum&#x27;] = session.get(&#x27;sum&#x27;) + num
    return Response(f&#x27;The sum is {session[&quot;sum&quot;]}.&#x27;)
```

## Toasts (also known as Messages)

Toasts, sometimes called “Messages” are small notifications usually in
colored boxes used to notify users that something has happened. Toasts
can be of four types:

- info
- success
- warning
- error

Examples toasts might include:

- “Payment accepted”
- “Data submitted”
- “Request approved”

Toasts require the use of the `setup_toasts()` function plus every view
needs these two features:

- The session argument
- Must return FT components

``` python
setup_toasts(app)

@rt(&#x27;/toasting&#x27;)
def get(session):
    # Normally one toast is enough, this allows us to see
    # different toast types in action.
    add_toast(session, f&quot;Toast is being cooked&quot;, &quot;info&quot;)
    add_toast(session, f&quot;Toast is ready&quot;, &quot;success&quot;)
    add_toast(session, f&quot;Toast is getting a bit crispy&quot;, &quot;warning&quot;)
    add_toast(session, f&quot;Toast is burning!&quot;, &quot;error&quot;)
    return Titled(&quot;I like toast&quot;)
```

Line 1  
`setup_toasts` is a helper function that adds toast dependencies.
Usually this would be declared right after `fast_app()`

Line 4  
Toasts require sessions

Line 11  
Views with Toasts must return FT components.

## Authentication and authorization

In FastHTML the tasks of authentication and authorization are handled
with Beforeware. Beforeware are functions that run before the route
handler is called. They are useful for global tasks like ensuring users
are authenticated or have permissions to access a view.

First, we write a function that accepts a request and session arguments:

``` python
# Status code 303 is a redirect that can change POST to GET,
# so it&#x27;s appropriate for a login page.
login_redir = RedirectResponse(&#x27;/login&#x27;, status_code=303)

def user_auth_before(req, sess):
    # The `auth` key in the request scope is automatically provided
    # to any handler which requests it, and can not be injected
    # by the user using query params, cookies, etc, so it should
    # be secure to use.    
    auth = req.scope[&#x27;auth&#x27;] = sess.get(&#x27;auth&#x27;, None)
    # If the session key is not there, it redirects to the login page.
    if not auth: return login_redir
```

Now we pass our `user_auth_before` function as the first argument into a
[`Beforeware`](https://AnswerDotAI.github.io/fasthtml/api/core.html#beforeware)
class. We also pass a list of regular expressions to the `skip`
argument, designed to allow users to still get to the home and login
pages.

``` python
beforeware = Beforeware(
    user_auth_before,
    skip=[r&#x27;/favicon\.ico&#x27;, r&#x27;/static/.*&#x27;, r&#x27;.*\.css&#x27;, r&#x27;.*\.js&#x27;, &#x27;/login&#x27;, &#x27;/&#x27;]
)

app, rt = fast_app(before=beforeware)
```

## Unwritten quickstart sections

- Forms
- Websockets
- Tables</doc>
    <doc title="Surreal" info="Tiny jQuery alternative for plain Javascript with inline Locality of Behavior, providing `me` and `any` functions"># 🗿 Surreal
### Tiny jQuery alternative for plain Javascript with inline [Locality of Behavior](https://htmx.org/essays/locality-of-behaviour/)!

![cover](https://user-images.githubusercontent.com/24665/171092805-b41286b2-be4a-4aab-9ee6-d604699cc507.png)
(Art by [shahabalizadeh](https://www.deviantart.com/shahabalizadeh))
&lt;!--
&lt;a href=&quot;https://github.com/gnat/surreal/archive/refs/heads/main.zip&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Download%20.zip-ff9800?style=for-the-badge&amp;color=%234400e5&quot; alt=&quot;Download badge&quot; /&gt;&lt;/a&gt;

&lt;a href=&quot;https://github.com/gnat/surreal&quot;&gt;&lt;img src=&quot;https://img.shields.io/github/workflow/status/gnat/surreal/ci?label=ci&amp;style=for-the-badge&amp;color=%237d91ce&quot; alt=&quot;CI build badge&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://github.com/gnat/surreal/releases&quot;&gt;&lt;img src=&quot;https://img.shields.io/github/workflow/status/gnat/surreal/release?label=Mini&amp;style=for-the-badge&amp;color=%237d91ce&quot; alt=&quot;Mini build badge&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://github.com/gnat/surreal/blob/main/LICENSE&quot;&gt;&lt;img src=&quot;https://img.shields.io/github/license/gnat/surreal?style=for-the-badge&amp;color=%234400e5&quot; alt=&quot;License badge&quot; /&gt;&lt;/a&gt;--&gt;

## Why does this exist?

For devs who love ergonomics! You may appreciate Surreal if:

* You want to stay as close as possible to Vanilla JS.
* Hate typing `document.querySelector` over.. and over..
* Hate typing `addEventListener` over.. and over..
* Really wish `document.querySelectorAll` had Array functions..
* Really wish `this` would work in any inline `&lt;script&gt;` tag
* Enjoyed using jQuery selector syntax.
* [Animations, timelines, tweens](#-quick-start) with no extra libraries.
* Only 320 lines. No build step. No dependencies.
* Pairs well with [htmx](https://htmx.org)
* Want fewer layers, less complexity. Are aware of the cargo cult. ✈️

## ✨ What does it add to Javascript?

* ⚡️ [Locality of Behavior (LoB)](https://htmx.org/essays/locality-of-behaviour/) Use `me()` inside `&lt;script&gt;`
  * No **.class** or **#id** needed! Get an element without creating a unique name.
  * `this` but much more flexible!
  * Want `me` in your CSS `&lt;style&gt;` tags, too? See our [companion script](https://github.com/gnat/css-scope-inline)
* 🔗 Call chaining, jQuery style.
* ♻️ Functions work seamlessly on 1 element or arrays of elements!
  * All functions can use: `me()`, `any()`, `NodeList`, `HTMLElement` (..or arrays of these!)
  * Get 1 element: `me()`
  * ..or many elements: `any()`
  * `me()` or `any()` can chain with any Surreal function.
    * `me()` can be used directly as a single element (like `querySelector()` or `$()`)
    * `any()` can use: `for` / `forEach` / `filter` / `map` (like `querySelectorAll()` or `$()`)
* 🌗 No forced style. Use: `classAdd` or `class_add` or `addClass` or `add_class`
  * Use `camelCase` (Javascript) or `snake_case` (Python, Rust, PHP, Ruby, SQL, CSS).

### 🤔 Why use `me()` / `any()` instead of `$()`
* 💡 Solves the classic jQuery bloat problem: Am I getting 1 element or an array of elements?
  * `me()` is guaranteed to return 1 element (or first found, or null).
  * `any()` is guaranteed to return an array (or empty array).
  * No more checks = write less code. Bonus: Reads more like self-documenting english.

## 👁️ How does it look?

Do surreal things with [Locality of Behavior](https://htmx.org/essays/locality-of-behaviour/) like:
```html
&lt;label for=&quot;file-input&quot; &gt;
  &lt;div class=&quot;uploader&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
    me().on(&quot;dragover&quot;, ev =&gt; { halt(ev); me(ev).classAdd(&#x27;.hover&#x27;); console.log(&quot;Files in drop zone.&quot;) })
    me().on(&quot;dragleave&quot;, ev =&gt; { halt(ev); me(ev).classRemove(&#x27;.hover&#x27;); console.log(&quot;Files left drop zone.&quot;) })
    me().on(&quot;drop&quot;, ev =&gt; { halt(ev); me(ev).classRemove(&#x27;.hover&#x27;).classAdd(&#x27;.loading&#x27;); me(&#x27;#file-input&#x27;).attribute(&#x27;files&#x27;, ev.dataTransfer.files); me(&#x27;#form&#x27;).send(&#x27;change&#x27;) })
  &lt;/script&gt;
&lt;/label&gt;
```

See the [Live Example](https://gnat.github.io/surreal/example.html)! Then [view source](https://github.com/gnat/surreal/blob/main/example.html).

## 🎁 Install

Surreal is only 320 lines. No build step. No dependencies.

[📥 Download](https://raw.githubusercontent.com/gnat/surreal/main/surreal.js) into your project, and add `&lt;script src=&quot;/surreal.js&quot;&gt;&lt;/script&gt;` in your `&lt;head&gt;`

Or, 🌐 via CDN: `&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/surreal/1.3.2/surreal.js&quot;&gt;&lt;/script&gt;`

## ⚡ Usage

### &lt;a name=&quot;selectors&quot;&gt;&lt;/a&gt;🔍️ DOM Selection

* Select **one** element: `me(...)`
  * Can be any of:
    * CSS selector: `&quot;.button&quot;`, `&quot;#header&quot;`, `&quot;h1&quot;`, `&quot;body &gt; .block&quot;`
    * Variables: `body`, `e`, `some_element`
    * Events: `event.currentTarget` will be used.
    * Surreal selectors: `me()`,`any()`
    * Choose the start location in the DOM with the 2nd arg. (Default: `document`)
      * 🔥 `any(&#x27;button&#x27;, me(&#x27;#header&#x27;)).classAdd(&#x27;red&#x27;)`
        * Add `.red` to any `&lt;button&gt;` inside of `#header`
  * `me()` ⭐ Get parent element of `&lt;script&gt;` without a **.class** or **#id** !
  * `me(&quot;body&quot;)` Gets `&lt;body&gt;`
  * `me(&quot;.button&quot;)` Gets the first `&lt;div class=&quot;button&quot;&gt;...&lt;/div&gt;`. To get all of them use `any()`
* Select **one or more** elements as an array: `any(...)`
  * Like `me()` but guaranteed to return an array (or empty array). 
  * `any(&quot;.foo&quot;)` ⭐ Get all matching elements.
  * Convert between arrays of elements and single elements: `any(me())`, `me(any(&quot;.something&quot;))`
 
### 🔥 DOM Functions

* ♻️ All functions work on single elements or arrays of elements.
* 🔗 Start a chain using `me()` and `any()`
  * 🟢 Style A `me().classAdd(&#x27;red&#x27;)` ⭐ Chain style. Recommended!
  * 🟠 Style B: `classAdd(me(), &#x27;red&#x27;)`
* 🌐 Global conveniences help you write less code.
  * `globalsAdd()` will automatically warn you of any clobbering issues!
  * 💀🩸 If you want no conveniences, or are a masochist, delete `globalsAdd()`
    * 🟢 `me().classAdd(&#x27;red&#x27;)` becomes `surreal.me().classAdd(&#x27;red&#x27;)`
    * 🟠 `classAdd(me(), &#x27;red&#x27;)` becomes `surreal.classAdd(surreal.me(), &#x27;red&#x27;)`

See: [Quick Start](#quick-start) and [Reference](#reference) and [No Surreal Needed](#no-surreal)

## &lt;a name=&quot;quick-start&quot;&gt;&lt;/a&gt;⚡ Quick Start

* Add a class
  * `me().classAdd(&#x27;red&#x27;)`
  * `any(&quot;button&quot;).classAdd(&#x27;red&#x27;)`
* Events
  * `me().on(&quot;click&quot;, ev =&gt; me(ev).fadeOut() )`
  * `any(&#x27;button&#x27;).on(&#x27;click&#x27;, ev =&gt; { me(ev).styles(&#x27;color: red&#x27;) })`
* Run functions over elements.
  * `any(&#x27;button&#x27;).run(_ =&gt; { alert(_) })`
* Styles / CSS
  * `me().styles(&#x27;color: red&#x27;)`
  * `me().styles({ &#x27;color&#x27;:&#x27;red&#x27;, &#x27;background&#x27;:&#x27;blue&#x27; })`
* Attributes
  * `me().attribute(&#x27;active&#x27;, true)`

&lt;a name=&quot;timelines&quot;&gt;&lt;/a&gt;
#### Timeline animations without any libraries.
```html
&lt;div&gt;I change color every second.
  &lt;script&gt;
    // On click, animate something new every second.
    me().on(&quot;click&quot;, async ev =&gt; {
      let el = me(ev) // Save target because async will lose it.
      me(el).styles({ &quot;transition&quot;: &quot;background 1s&quot; })
      await sleep(1000)
      me(el).styles({ &quot;background&quot;: &quot;red&quot; })
      await sleep(1000)
      me(el).styles({ &quot;background&quot;: &quot;green&quot; })
      await sleep(1000)
      me(el).styles({ &quot;background&quot;: &quot;blue&quot; })
      await sleep(1000)
      me(el).styles({ &quot;background&quot;: &quot;none&quot; })
      await sleep(1000)
      me(el).remove()
    })
  &lt;/script&gt;
&lt;/div&gt;
```
```html
&lt;div&gt;I fade out and remove myself.
  &lt;script&gt;me().on(&quot;click&quot;, ev =&gt; { me(ev).fadeOut() })&lt;/script&gt;
&lt;/div&gt;
```
```html
&lt;div&gt;Change color every second.
  &lt;script&gt;
    // Run immediately.
    (async (e = me()) =&gt; {
      me(e).styles({ &quot;transition&quot;: &quot;background 1s&quot; })
      await sleep(1000)
      me(e).styles({ &quot;background&quot;: &quot;red&quot; })
      await sleep(1000)
      me(e).styles({ &quot;background&quot;: &quot;green&quot; })
      await sleep(1000)
      me(e).styles({ &quot;background&quot;: &quot;blue&quot; })
      await sleep(1000)
      me(e).styles({ &quot;background&quot;: &quot;none&quot; })
      await sleep(1000)
      me(e).remove()
    })()
  &lt;/script&gt;
&lt;/div&gt;
```
```html
&lt;script&gt;
  // Run immediately, for every &lt;button&gt; globally!
  (async () =&gt; {
    any(&quot;button&quot;).fadeOut()
  })()
&lt;/script&gt;
```
#### Array methods
```js
any(&#x27;button&#x27;)?.forEach(...)
any(&#x27;button&#x27;)?.map(...)
```

## &lt;a name=&quot;reference&quot;&gt;&lt;/a&gt;👁️ Functions
Looking for [DOM Selectors](#selectors)?
Looking for stuff [we recommend doing in vanilla JS](#no-surreal)?
### 🧭 Legend
* 🔗 Chainable off `me()` and `any()`
* 🌐 Global shortcut.
* 🔥 Runnable example.
* 🔌 Built-in Plugin
### 👁️ At a glance

* 🔗 `run`
  * It&#x27;s `forEach` but less wordy and works on single elements, too!
  * 🔥 `me().run(e =&gt; { alert(e) })`
  * 🔥 `any(&#x27;button&#x27;).run(e =&gt; { alert(e) })`
* 🔗 `remove`
  * 🔥 `me().remove()`
  * 🔥 `any(&#x27;button&#x27;).remove()`
* 🔗 `classAdd` 🌗 `class_add` 🌗 `addClass` 🌗 `add_class`
  * 🔥 `me().classAdd(&#x27;active&#x27;)`
  * Leading `.` is **optional**
    * Same thing: `me().classAdd(&#x27;active&#x27;)` 🌗 `me().classAdd(&#x27;.active&#x27;)`
* 🔗 `classRemove` 🌗 `class_remove` 🌗 `removeClass` 🌗 `remove_class`
  * 🔥 `me().classRemove(&#x27;active&#x27;)`
* 🔗 `classToggle` 🌗 `class_toggle` 🌗 `toggleClass` 🌗 `toggle_class`
  * 🔥 `me().classToggle(&#x27;active&#x27;)`
* 🔗 `styles`
  * 🔥 `me().styles(&#x27;color: red&#x27;)` Add style.
  * 🔥 `me().styles({ &#x27;color&#x27;:&#x27;red&#x27;, &#x27;background&#x27;:&#x27;blue&#x27; })` Add multiple styles.
  * 🔥 `me().styles({ &#x27;background&#x27;:null })` Remove style.
* 🔗 `attribute` 🌗 `attributes` 🌗 `attr`
  * Get: 🔥 `me().attribute(&#x27;data-x&#x27;)`
    * For single elements.
    * For many elements, wrap it in: `any(...).run(...)` or `any(...).forEach(...)`
  * Set: 🔥`me().attribute(&#x27;data-x&#x27;, true)`
  * Set multiple: 🔥 `me().attribute({ &#x27;data-x&#x27;:&#x27;yes&#x27;, &#x27;data-y&#x27;:&#x27;no&#x27; })`
  * Remove: 🔥 `me().attribute(&#x27;data-x&#x27;, null)`
  * Remove multiple: 🔥 `me().attribute({ &#x27;data-x&#x27;: null, &#x27;data-y&#x27;:null })`
* 🔗 `send` 🌗 `trigger`
  * 🔥 `me().send(&#x27;change&#x27;)`
  * 🔥 `me().send(&#x27;change&#x27;, {&#x27;data&#x27;:&#x27;thing&#x27;})`
  * Wraps `dispatchEvent`
* 🔗 `on`
  * 🔥 `me().on(&#x27;click&#x27;, ev =&gt; { me(ev).styles(&#x27;background&#x27;, &#x27;red&#x27;) })`
  * Wraps `addEventListener`
* 🔗 `off`
  * 🔥 `me().off(&#x27;click&#x27;, fn)`
  * Wraps `removeEventListener`
* 🔗 `offAll`
  * 🔥 `me().offAll()`
* 🔗 `disable`
  * 🔥 `me().disable()`
  * Easy alternative to `off()`. Disables click, key, submit events.
* 🔗 `enable`
  * 🔥 `me().enable()`
  * Opposite of `disable()`
* 🌐 `sleep`
  * 🔥 `await sleep(1000, ev =&gt; { alert(ev) })`
  * `async` version of `setTimeout`
  * Wonderful for animation timelines.
* 🌐 `tick`
  * 🔥 `await tick()`
  * `await` version of `rAF` / `requestAnimationFrame`.
  * Animation tick. Waits 1 frame.
  * Great if you need to wait for events to propagate.
* 🌐 `rAF`
  * 🔥 `rAF(e =&gt; { return e })`
  * Animation tick.  Fires when 1 frame has passed. Alias of [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
  * Great if you need to wait for events to propagate.
* 🌐 `rIC`
  * 🔥 `rIC(e =&gt; { return e })`
  * Great time to compute. Fires function when JS is idle. Alias of [requestIdleCallback](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback)
* 🌐 `halt`
  * 🔥 `halt(event)`
  * Prevent default browser behaviors.
  * Wrapper for [preventDefault](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
* 🌐 `createElement` 🌗 `create_element`
  * 🔥 `e_new = createElement(&quot;div&quot;); me().prepend(e_new)`
  * Alias of vanilla `document.createElement`
* 🌐 `onloadAdd` 🌗 `onload_add` 🌗 `addOnload` 🌗 `add_onload`
  * 🔥 `onloadAdd(_ =&gt; { alert(&quot;loaded!&quot;); })`
  * 🔥 `&lt;script&gt;let e = me(); onloadAdd(_ =&gt; { me(e).on(&quot;click&quot;, ev =&gt; { alert(&quot;clicked&quot;) }) })&lt;/script&gt;`
  * Execute after the DOM is ready. Similar to jquery `ready()`
  * Add to `window.onload` while preventing overwrites of `window.onload` and predictable loading!
  * Alternatives:
    * Skip missing elements using `?.` example: `me(&quot;video&quot;)?.requestFullscreen()`
    * Place `&lt;script&gt;` after the loaded element.
      * See `me(&#x27;-&#x27;)` / `me(&#x27;prev&#x27;)`
* 🔌 `fadeOut`
  * See below
* 🔌 `fadeIn`
  * See below

### &lt;a name=&quot;plugin-included&quot;&gt;&lt;/a&gt;🔌 Built-in Plugins

### Effects
Build effects with `me().styles({...})` with timelines using [CSS transitioned `await` or callbacks](#timelines).

Common effects included:

* 🔗 `fadeOut` 🌗 `fade_out`
  * Fade out and remove element.
  * Keep element with `remove=false`.
  * 🔥 `me().fadeOut()`
  * 🔥 `me().fadeOut(ev =&gt; { alert(&quot;Faded out!&quot;) }, 3000)` Over 3 seconds then call function.

* 🔗 `fadeIn` 🌗 `fade_in`
  * Fade in existing element which has `opacity: 0`
  * 🔥 `me().fadeIn()`
  * 🔥 `me().fadeIn(ev =&gt; { alert(&quot;Faded in!&quot;) }, 3000)` Over 3 seconds then call function.


## &lt;a name=&quot;no-surreal&quot;&gt;&lt;/a&gt;⚪ No Surreal Needed

More often than not, Vanilla JS is the easiest way!

Logging
* 🔥 `console.log()` `console.warn()` `console.error()`
* Event logging: 🔥 `monitorEvents(me())` See: [Chrome Blog](https://developer.chrome.com/blog/quickly-monitor-events-from-the-console-panel-2/)

Benchmarking / Time It!
* 🔥 `console.time(&#x27;name&#x27;)`
* 🔥 `console.timeEnd(&#x27;name&#x27;)`

Text / HTML Content
* 🔥 `me().textContent = &quot;hello world&quot;`
  * XSS Safe! See: [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent)
* 🔥 `me().innerHTML = &quot;&lt;p&gt;hello world&lt;/p&gt;&quot;`
* 🔥 `me().innerText = &quot;hello world&quot;`

Children
* 🔥 `me().children`
* 🔥 `me().children.hidden = true`

Append / Prepend elements.
* 🔥 `me().prepend(new_element)`
* 🔥 `me().appendChild(new_element)`
* 🔥 `me().insertBefore(element, other_element.firstChild)`
* 🔥 `me().insertAdjacentHTML(&quot;beforebegin&quot;, new_element)`

AJAX (replace jQuery `ajax()`)
* Use [htmx](https://htmx.org/) or [htmz](https://leanrada.com/htmz/) or [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) or [XMLHttpRequest()](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) directly.
* Using `fetch()`
```js
me().on(&quot;click&quot;, async event =&gt; {
  let e = me(event)
  // EXAMPLE 1: Hit an endpoint.
  if((await fetch(&quot;/webhook&quot;)).ok) console.log(&quot;Did the thing.&quot;)
  // EXAMPLE 2: Get content and replace me()
  try {
    let response = await fetch(&#x27;/endpoint&#x27;)
    if (response.ok) e.innerHTML = await response.text()
    else console.warn(&#x27;fetch(): Bad response&#x27;)
  }
  catch (error) { console.warn(`fetch(): ${error}`) }
})
```
* Using `XMLHttpRequest()`
```js
me().on(&quot;click&quot;, async event =&gt; {
  let e = me(event)
  // EXAMPLE 1: Hit an endpoint.
  var xhr = new XMLHttpRequest()
  xhr.open(&quot;GET&quot;, &quot;/webhook&quot;)
  xhr.send()
  // EXAMPLE 2: Get content and replace me()
  var xhr = new XMLHttpRequest()
  xhr.open(&quot;GET&quot;, &quot;/endpoint&quot;)
  xhr.onreadystatechange = () =&gt; {
    if (xhr.readyState == 4 &amp;&amp; xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) e.innerHTML = xhr.responseText
  }
  xhr.send()
})
```

 ## 💎 Conventions &amp; Tips

* Many ideas can be done in HTML / CSS (ex: dropdowns)
* `_` = for temporary or unused variables. Keep it short and sweet!
* `e`, `el`, `elt` = element
* `e`, `ev`, `evt` = event
* `f`, `fn` = function

#### Scope functions inside `&lt;script&gt;`
  * ⭐ On `me()`
    *  `me().hey = (text) =&gt; { alert(text) }`
    *  `me().on(&#x27;click&#x27;, (ev) =&gt; { me(ev).hey(&quot;hi&quot;) })`
  * ⭐ Use a block: `{ function hey(text) { alert(text) }; me().on(&#x27;click&#x27;, ev =&gt; { hey(&quot;hi&quot;) }) }`
  * ⭐ Use an event: `me().on(&#x27;click&#x27;, ev =&gt; { /* add and call function here */ })`
  * Use an inline module: `&lt;script type=&quot;module&quot;&gt;`
    * Note: `me()` will no longer see `parentElement` so explicit selectors are required: `me(&quot;.mybutton&quot;)`

#### Select a void element like `&lt;input type=&quot;text&quot; /&gt;`
* Use: `me(&#x27;-&#x27;)` or `me(&#x27;prev&#x27;)` or `me(&#x27;previous&#x27;)`
  * 🔥 `&lt;input type=&quot;text&quot; /&gt; &lt;script&gt;me(&#x27;-&#x27;).value = &quot;hello&quot;&lt;/script&gt;`
  * Inspired by the CSS &quot;next sibling&quot; combinator `+` but in reverse `-`
* Or, use a relative start.
  * 🔥 `&lt;form&gt; &lt;input type=&quot;text&quot; n1 /&gt; &lt;script&gt;me(&#x27;[n1]&#x27;, me()).value = &quot;hello&quot;&lt;/script&gt; &lt;/form&gt;`

#### Ignore call chain when element is missing.
* 🔥 `me(&quot;#i_dont_exist&quot;)?.classAdd(&#x27;active&#x27;)`
* No warnings: 🔥 `me(&quot;#i_dont_exist&quot;, document, false)?.classAdd(&#x27;active&#x27;)`

## &lt;a name=&quot;plugins&quot;&gt;&lt;/a&gt;🔌 Your own plugin

Feel free to edit Surreal directly- but if you prefer, you can use plugins to effortlessly merge with new versions.

```javascript
function pluginHello(e) {
  function hello(e, name=&quot;World&quot;) {
    console.log(`Hello ${name} from ${e}`)
    return e // Make chainable.
  }
  // Add sugar
  e.hello = (name) =&gt; { return hello(e, name) }
}

surreal.plugins.push(pluginHello)
```

Now use your function like: `me().hello(&quot;Internet&quot;)`

* See the included `pluginEffects` for a more comprehensive example.
* Your functions are added globally by `globalsAdd()` If you do not want this, add it to the `restricted` list.
* Refer to an existing function to see how to make yours work with 1 or many elements.

Make an [issue](https://github.com/gnat/surreal/issues) or [pull request](https://github.com/gnat/surreal/pulls) if you think people would like to use it! If it&#x27;s useful enough we&#x27;ll want it in core.

### ⭐ Awesome Surreal examples, plugins, and resources: [awesome-surreal](https://github.com/gnat/awesome-surreal) !

## 📚️ Inspired by

* [jQuery](https://jquery.com/) for the chainable syntax we all love.
* [BlingBling.js](https://github.com/argyleink/blingblingjs) for modern minimalism.
* [Bliss.js](https://blissfuljs.com/) for a focus on single elements and extensibility.
* [Hyperscript](https://hyperscript.org) for Locality of Behavior and awesome ergonomics.
* Shout out to [Umbrella](https://umbrellajs.com/), [Cash](https://github.com/fabiospampinato/cash), [Zepto](https://zeptojs.com/)- Not quite as ergonomic. Requires build step to extend.

## 🌘 Future
* Always more `example.html` goodies!
* Automated browser testing perhaps with:
  * [Fava](https://github.com/fabiospampinato/fava). See: https://github.com/avajs/ava/issues/24#issuecomment-885949036
  * [Ava](https://github.com/avajs/ava/blob/main/docs/recipes/browser-testing.md)
  * [jsdom](https://github.com/jsdom/jsdom)
    * [jsdom notes](https://github.com/jsdom/jsdom#executing-scripts)</doc>
    <doc title="CSS Scope Inline" info="A JS library which allow `me` to be used in CSS selectors, by using a `MutationObserver` to monitor the DOM"># 🌘 CSS Scope Inline

![cover](https://github.com/gnat/css-scope-inline/assets/24665/c4935c1b-34e3-4220-9d42-11f064999a57)
(Art by [shahabalizadeh](https://www.artstation.com/artwork/zDgdd))

## Why does this exist?

* You want an easy inline vanilla CSS experience without Tailwind CSS.
* Hate creating unique class names over.. and over.. to use once.
* You want to co-locate your styles for ⚡️ [Locality of Behavior (LoB)](https://htmx.org/essays/locality-of-behaviour/)
* You wish `this` would work in `&lt;style&gt;` tags.
* Want all CSS features: [Nesting](https://caniuse.com/css-nesting), animations. Get scoped [`@keyframes`](https://github.com/gnat/css-scope-inline/blob/main/example.html#L86)!
* You wish `@media` queries were shorter for [responsive design](https://tailwindcss.com/docs/responsive-design).
* Only 16 lines. No build step. No dependencies.
* Pairs well with [htmx](https://htmx.org) and [Surreal](https://github.com/gnat/surreal)
* Want fewer layers, less complexity. Are aware of the cargo cult. ✈️

✨ Want to also scope your `&lt;script&gt;` tags? See our companion project [Surreal](https://github.com/gnat/surreal)

## 👁️ How does it look?
```html
&lt;div&gt;
    &lt;style&gt;
        me { background: red; } /* ✨ this &amp; self also work! */
        me button { background: blue; } /* style child elements inline! */
    &lt;/style&gt;
    &lt;button&gt;I&#x27;m blue&lt;/button&gt;
&lt;/div&gt;
```
See the [Live Example](https://gnat.github.io/css-scope-inline/example.html)! Then [view source](https://github.com/gnat/css-scope-inline/blob/main/example.html).

## 🌘 How does it work?

This uses `MutationObserver` to monitor the DOM, and the moment a `&lt;style&gt;` tag is seen, it scopes the styles to whatever the parent element is. No flashing or popping. 

This method also leaves your existing styles untouched, allowing you to mix and match at your leisure.

## 🎁 Install

✂️ copy + 📋 paste the snippet into `&lt;script&gt;` in your `&lt;head&gt;`

Or, [📥 download](https://raw.githubusercontent.com/gnat/css-scope-inline/main/script.js) into your project, and add `&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;` in your `&lt;head&gt;`

Or, 🌐 CDN: `&lt;script src=&quot;https://cdn.jsdelivr.net/gh/gnat/css-scope-inline@main/script.js&quot;&gt;&lt;/script&gt;`

## 🤔 Why consider this over Tailwind CSS?

Use whatever you&#x27;d like, but there&#x27;s a few advantages with this approach over Tailwind, Twind, UnoCSS:

* No more [repeating styles](https://tailwindcss.com/docs/reusing-styles) on child elements (..no [@apply](https://tailwindcss.com/docs/reusing-styles#extracting-classes-with-apply), no `[&amp;&gt;thing]` per style). It&#x27;s just CSS!
* No endless visual noise on every `&lt;div&gt;`. Use a local `&lt;style&gt;` per group.
* No high risk of eventually requiring a build step.
* No chance of [deprecations](https://windicss.org/posts/sunsetting.html). 16 lines is infinitely maintainable.
* Get the ultra-fast &quot;inspect, play with styles, paste&quot; workflow back.
* No suffering from FOUC (a flash of unstyled content).
* Zero friction movement of styles between inline and `.css` files. Just replace `me`
* No special tooling or plugins to install. Universal vanilla CSS. 

## ⚡ Workflow Tips

* Flat, 1 selector per line can be very short like Tailwind. See the examples.
* Use just plain CSS variables in your design system.
* Use the short `@media` queries for responsive design.
  * Mobile First (flow: **above** breakpoint): **🟢 None** `sm` `md` `lg` `xl` `xx` 🏁
  * Desktop First (flow: **below** breakpoint): 🏁 `xs-` `sm-` `md-` `lg-` `xl-` **🟢 None**
  * 🟢 = No breakpoint. Default. See the [Live Example](https://gnat.github.io/css-scope-inline/example.html)!
  * Based on [Tailwind](https://tailwindcss.com/docs/responsive-design) breakpoints. We use `xx` not `2xl` to not break CSS highlighters.
  * Unlike Tailwind, you can [nest your @media styles](https://developer.chrome.com/articles/css-nesting/#nesting-media)!
* Positional selectors may be easier using `div[n1]` for `&lt;div n1&gt;` instead of `div:nth-child(1)`
* Try tools like- Auto complete styles: [VSCode](https://code.visualstudio.com/) or [Sublime](https://packagecontrol.io/packages/Emmet)

## 👁️ CSS Scope Inline vs Tailwind CSS Showdowns
### Basics
Tailwind verbosity goes up with more child elements.
```html
&lt;div&gt;
    &lt;style&gt;
        me { background: red; }
        me div { background: green; }
        me div[n1] { background: yellow; }
        me div[n2] { background: blue; }
    &lt;/style&gt;
    red
    &lt;div&gt;green&lt;/div&gt;
    &lt;div&gt;green&lt;/div&gt;
    &lt;div&gt;green&lt;/div&gt;
    &lt;div n1&gt;yellow&lt;/div&gt;
    &lt;div n2&gt;blue&lt;/div&gt;
    &lt;div&gt;green&lt;/div&gt;
    &lt;div&gt;green&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;bg-[red]&quot;&gt;
    red
    &lt;div class=&quot;bg-[green]&quot;&gt;green&lt;/div&gt;
    &lt;div class=&quot;bg-[green]&quot;&gt;green&lt;/div&gt;
    &lt;div class=&quot;bg-[green]&quot;&gt;green&lt;/div&gt;
    &lt;div class=&quot;bg-[yellow]&quot;&gt;yellow&lt;/div&gt;
    &lt;div class=&quot;bg-[blue]&quot;&gt;blue&lt;/div&gt;
    &lt;div class=&quot;bg-[green]&quot;&gt;green&lt;/div&gt;
    &lt;div class=&quot;bg-[green]&quot;&gt;green&lt;/div&gt;
&lt;/div&gt;
```
### CSS variables and child styling
```html
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;style&gt;
            :root {
                --color-1: hsl(0 0% 88%);
                --color-1-active: hsl(214 20% 70%);
            }
        &lt;/style&gt;
        &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;https://cdn.jsdelivr.net/gh/gnat/css-scope-inline@main/script.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- CSS Scope Inline --&gt;
        &lt;div&gt;
            &lt;style&gt;
               me { margin:8px 6px; }
               me div a { display:block; padding:8px 12px; margin:10px 0; background:var(--color-1); border-radius:10px; text-align:center; }
               me div a:hover { background:var(--color-1-active); color:white; }
            &lt;/style&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Team&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Settings&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Log Out&lt;/a&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Tailwind Example 1 --&gt;
        &lt;div class=&quot;mx-2 my-4&quot;&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot; class=&quot;block py-2 px-3 my-2 bg-[--color-1] rounded-lg text-center hover:bg-[--color-1-active] hover:text-white&quot;&gt;Home&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot; class=&quot;block py-2 px-3 my-2 bg-[--color-1] rounded-lg text-center hover:bg-[--color-1-active] hover:text-white&quot;&gt;Team&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot; class=&quot;block py-2 px-3 my-2 bg-[--color-1] rounded-lg text-center hover:bg-[--color-1-active] hover:text-white&quot;&gt;Profile&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot; class=&quot;block py-2 px-3 my-2 bg-[--color-1] rounded-lg text-center hover:bg-[--color-1-active] hover:text-white&quot;&gt;Settings&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot; class=&quot;block py-2 px-3 my-2 bg-[--color-1] rounded-lg text-center hover:bg-[--color-1-active] hover:text-white&quot;&gt;Log Out&lt;/a&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Tailwind Example 2 --&gt;
        &lt;div class=&quot;mx-2 my-4
            [&amp;_div_a]:block [&amp;_div_a]:py-2 [&amp;_div_a]:px-3 [&amp;_div_a]:my-2 [&amp;_div_a]:bg-[--color-1] [&amp;_div_a]:rounded-lg [&amp;_div_a]:text-center
            [&amp;_div_a:hover]:bg-[--color-1-active] [&amp;_div_a:hover]:text-white&quot;&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Team&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Settings&lt;/a&gt;&lt;/div&gt;
            &lt;div&gt;&lt;a href=&quot;#&quot;&gt;Log Out&lt;/a&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
```
## 🔎 Technical FAQ
* Why do you use `querySelectorAll()` and not just process the `MutationObserver` results directly?
  * This was indeed the original design; it will work well up until you begin recieving subtrees (ex: DOM swaps with [htmx](https://htmx.org), ajax, jquery, etc.) which requires walking all subtree elements to ensure we do not miss a `&lt;style&gt;`. This unfortunately involves re-scanning thousands of repeated elements. This is why `querySelectorAll()` ends up the performance (and simplicity) winner.</doc>
    <doc title="HTMX reference" info="Brief description of all HTMX attributes, CSS classes, headers, events, extensions, js lib methods, and config options">+++
title = &quot;Reference&quot;
+++

## Contents

* [htmx Core Attributes](#attributes)
* [htmx Additional Attributes](#attributes-additional)
* [htmx CSS Classes](#classes)
* [htmx Request Headers](#request_headers)
* [htmx Response Headers](#response_headers)
* [htmx Events](#events)
* [htmx Extensions](https://extensions.htmx.org)
* [JavaScript API](#api)
* [Configuration Options](#config)

## Core Attribute Reference {#attributes}

The most common attributes when using htmx.

&lt;div class=&quot;info-table&quot;&gt;

| Attribute                                        | Description                                                                                                        |
|--------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| [`hx-get`](@/attributes/hx-get.md)               | issues a `GET` to the specified URL                                                                                |
| [`hx-post`](@/attributes/hx-post.md)             | issues a `POST` to the specified URL                                                                               |
| [`hx-on*`](@/attributes/hx-on.md)                | handle events with inline scripts on elements                                                                      |
| [`hx-push-url`](@/attributes/hx-push-url.md)     | push a URL into the browser location bar to create history                                                         |
| [`hx-select`](@/attributes/hx-select.md)         | select content to swap in from a response                                                                          |
| [`hx-select-oob`](@/attributes/hx-select-oob.md) | select content to swap in from a response, somewhere other than the target (out of band)                           |
| [`hx-swap`](@/attributes/hx-swap.md)             | controls how content will swap in (`outerHTML`, `beforeend`, `afterend`, ...)                                      |
| [`hx-swap-oob`](@/attributes/hx-swap-oob.md)     | mark element to swap in from a response (out of band)                                                              |
| [`hx-target`](@/attributes/hx-target.md)         | specifies the target element to be swapped                                                                         |
| [`hx-trigger`](@/attributes/hx-trigger.md)       | specifies the event that triggers the request                                                                      |
| [`hx-vals`](@/attributes/hx-vals.md)             | add values to submit with the request (JSON format)                                                                |

&lt;/div&gt;

## Additional Attribute Reference {#attributes-additional}

All other attributes available in htmx.

&lt;div class=&quot;info-table&quot;&gt;

| Attribute                                            | Description                                                                                                                        |
|------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| [`hx-boost`](@/attributes/hx-boost.md)               | add [progressive enhancement](https://en.wikipedia.org/wiki/Progressive_enhancement) for links and forms                           |
| [`hx-confirm`](@/attributes/hx-confirm.md)           | shows a `confirm()` dialog before issuing a request                                                                                |
| [`hx-delete`](@/attributes/hx-delete.md)             | issues a `DELETE` to the specified URL                                                                                             |
| [`hx-disable`](@/attributes/hx-disable.md)           | disables htmx processing for the given node and any children nodes                                                                 |
| [`hx-disabled-elt`](@/attributes/hx-disabled-elt.md) | adds the `disabled` attribute to the specified elements while a request is in flight                                               |
| [`hx-disinherit`](@/attributes/hx-disinherit.md)     | control and disable automatic attribute inheritance for child nodes                                                                |
| [`hx-encoding`](@/attributes/hx-encoding.md)         | changes the request encoding type                                                                                                  |
| [`hx-ext`](@/attributes/hx-ext.md)                   | extensions to use for this element                                                                                                 |
| [`hx-headers`](@/attributes/hx-headers.md)           | adds to the headers that will be submitted with the request                                                                        |
| [`hx-history`](@/attributes/hx-history.md)           | prevent sensitive data being saved to the history cache                                                                            |
| [`hx-history-elt`](@/attributes/hx-history-elt.md)   | the element to snapshot and restore during history navigation                                                                      |
| [`hx-include`](@/attributes/hx-include.md)           | include additional data in requests                                                                                                |
| [`hx-indicator`](@/attributes/hx-indicator.md)       | the element to put the `htmx-request` class on during the request                                                                  |
| [`hx-inherit`](@/attributes/hx-inherit.md)           | control and enable automatic attribute inheritance for child nodes if it has been disabled by default                            |
| [`hx-params`](@/attributes/hx-params.md)             | filters the parameters that will be submitted with a request                                                                       |
| [`hx-patch`](@/attributes/hx-patch.md)               | issues a `PATCH` to the specified URL                                                                                              |
| [`hx-preserve`](@/attributes/hx-preserve.md)         | specifies elements to keep unchanged between requests                                                                              |
| [`hx-prompt`](@/attributes/hx-prompt.md)             | shows a `prompt()` before submitting a request                                                                                     |
| [`hx-put`](@/attributes/hx-put.md)                   | issues a `PUT` to the specified URL                                                                                                |
| [`hx-replace-url`](@/attributes/hx-replace-url.md)   | replace the URL in the browser location bar                                                                                        |
| [`hx-request`](@/attributes/hx-request.md)           | configures various aspects of the request                                                                                          |
| [`hx-sync`](@/attributes/hx-sync.md)                 | control how requests made by different elements are synchronized                                                                   |
| [`hx-validate`](@/attributes/hx-validate.md)         | force elements to validate themselves before a request                                                                             |
| [`hx-vars`](@/attributes/hx-vars.md)                 | adds values dynamically to the parameters to submit with the request (deprecated, please use [`hx-vals`](@/attributes/hx-vals.md)) |

&lt;/div&gt;

## CSS Class Reference {#classes}

&lt;div class=&quot;info-table&quot;&gt;

| Class | Description |
|-----------|-------------|
| `htmx-added` | Applied to a new piece of content before it is swapped, removed after it is settled.
| `htmx-indicator` | A dynamically generated class that will toggle visible (opacity:1) when a `htmx-request` class is present
| `htmx-request` | Applied to either the element or the element specified with [`hx-indicator`](@/attributes/hx-indicator.md) while a request is ongoing
| `htmx-settling` | Applied to a target after content is swapped, removed after it is settled. The duration can be modified via [`hx-swap`](@/attributes/hx-swap.md).
| `htmx-swapping` | Applied to a target before any content is swapped, removed after it is swapped. The duration can be modified via [`hx-swap`](@/attributes/hx-swap.md).

&lt;/div&gt;

## HTTP Header Reference {#headers}

### Request Headers Reference {#request_headers}

&lt;div class=&quot;info-table&quot;&gt;

| Header | Description |
|--------|-------------|
| `HX-Boosted` | indicates that the request is via an element using [hx-boost](@/attributes/hx-boost.md)
| `HX-Current-URL` | the current URL of the browser
| `HX-History-Restore-Request` | &quot;true&quot; if the request is for history restoration after a miss in the local history cache
| `HX-Prompt` | the user response to an [hx-prompt](@/attributes/hx-prompt.md)
| `HX-Request` | always &quot;true&quot;
| `HX-Target` | the `id` of the target element if it exists
| `HX-Trigger-Name` | the `name` of the triggered element if it exists
| `HX-Trigger` | the `id` of the triggered element if it exists

&lt;/div&gt;

### Response Headers Reference {#response_headers}

&lt;div class=&quot;info-table&quot;&gt;

| Header                                               | Description |
|------------------------------------------------------|-------------|
| [`HX-Location`](@/headers/hx-location.md)            | allows you to do a client-side redirect that does not do a full page reload
| [`HX-Push-Url`](@/headers/hx-push-url.md)            | pushes a new url into the history stack
| `HX-Redirect`                                        | can be used to do a client-side redirect to a new location
| `HX-Refresh`                                         | if set to &quot;true&quot; the client-side will do a full refresh of the page
| [`HX-Replace-Url`](@/headers/hx-replace-url.md)      | replaces the current URL in the location bar
| `HX-Reswap`                                          | allows you to specify how the response will be swapped. See [hx-swap](@/attributes/hx-swap.md) for possible values
| `HX-Retarget`                                        | a CSS selector that updates the target of the content update to a different element on the page
| `HX-Reselect`                                        | a CSS selector that allows you to choose which part of the response is used to be swapped in. Overrides an existing [`hx-select`](@/attributes/hx-select.md) on the triggering element
| [`HX-Trigger`](@/headers/hx-trigger.md)              | allows you to trigger client-side events
| [`HX-Trigger-After-Settle`](@/headers/hx-trigger.md) | allows you to trigger client-side events after the settle step
| [`HX-Trigger-After-Swap`](@/headers/hx-trigger.md)   | allows you to trigger client-side events after the swap step

&lt;/div&gt;

## Event Reference {#events}

&lt;div class=&quot;info-table&quot;&gt;

| Event | Description |
|-------|-------------|
| [`htmx:abort`](@/events.md#htmx:abort) | send this event to an element to abort a request
| [`htmx:afterOnLoad`](@/events.md#htmx:afterOnLoad) | triggered after an AJAX request has completed processing a successful response
| [`htmx:afterProcessNode`](@/events.md#htmx:afterProcessNode) | triggered after htmx has initialized a node
| [`htmx:afterRequest`](@/events.md#htmx:afterRequest)  | triggered after an AJAX request has completed
| [`htmx:afterSettle`](@/events.md#htmx:afterSettle)  | triggered after the DOM has settled
| [`htmx:afterSwap`](@/events.md#htmx:afterSwap)  | triggered after new content has been swapped in
| [`htmx:beforeCleanupElement`](@/events.md#htmx:beforeCleanupElement)  | triggered before htmx [disables](@/attributes/hx-disable.md) an element or removes it from the DOM
| [`htmx:beforeOnLoad`](@/events.md#htmx:beforeOnLoad)  | triggered before any response processing occurs
| [`htmx:beforeProcessNode`](@/events.md#htmx:beforeProcessNode) | triggered before htmx initializes a node
| [`htmx:beforeRequest`](@/events.md#htmx:beforeRequest)  | triggered before an AJAX request is made
| [`htmx:beforeSwap`](@/events.md#htmx:beforeSwap)  | triggered before a swap is done, allows you to configure the swap
| [`htmx:beforeSend`](@/events.md#htmx:beforeSend)  | triggered just before an ajax request is sent
| [`htmx:configRequest`](@/events.md#htmx:configRequest)  | triggered before the request, allows you to customize parameters, headers
| [`htmx:confirm`](@/events.md#htmx:confirm)  | triggered after a trigger occurs on an element, allows you to cancel (or delay) issuing the AJAX request
| [`htmx:historyCacheError`](@/events.md#htmx:historyCacheError)  | triggered on an error during cache writing
| [`htmx:historyCacheMiss`](@/events.md#htmx:historyCacheMiss)  | triggered on a cache miss in the history subsystem
| [`htmx:historyCacheMissError`](@/events.md#htmx:historyCacheMissError)  | triggered on a unsuccessful remote retrieval
| [`htmx:historyCacheMissLoad`](@/events.md#htmx:historyCacheMissLoad)  | triggered on a successful remote retrieval
| [`htmx:historyRestore`](@/events.md#htmx:historyRestore)  | triggered when htmx handles a history restoration action
| [`htmx:beforeHistorySave`](@/events.md#htmx:beforeHistorySave)  | triggered before content is saved to the history cache
| [`htmx:load`](@/events.md#htmx:load)  | triggered when new content is added to the DOM
| [`htmx:noSSESourceError`](@/events.md#htmx:noSSESourceError)  | triggered when an element refers to a SSE event in its trigger, but no parent SSE source has been defined
| [`htmx:onLoadError`](@/events.md#htmx:onLoadError)  | triggered when an exception occurs during the onLoad handling in htmx
| [`htmx:oobAfterSwap`](@/events.md#htmx:oobAfterSwap)  | triggered after an out of band element as been swapped in
| [`htmx:oobBeforeSwap`](@/events.md#htmx:oobBeforeSwap)  | triggered before an out of band element swap is done, allows you to configure the swap
| [`htmx:oobErrorNoTarget`](@/events.md#htmx:oobErrorNoTarget)  | triggered when an out of band element does not have a matching ID in the current DOM
| [`htmx:prompt`](@/events.md#htmx:prompt)  | triggered after a prompt is shown
| [`htmx:pushedIntoHistory`](@/events.md#htmx:pushedIntoHistory)  | triggered after an url is pushed into history
| [`htmx:responseError`](@/events.md#htmx:responseError)  | triggered when an HTTP response error (non-`200` or `300` response code) occurs
| [`htmx:sendError`](@/events.md#htmx:sendError)  | triggered when a network error prevents an HTTP request from happening
| [`htmx:sseError`](@/events.md#htmx:sseError)  | triggered when an error occurs with a SSE source
| [`htmx:sseOpen`](/events#htmx:sseOpen)  | triggered when a SSE source is opened
| [`htmx:swapError`](@/events.md#htmx:swapError)  | triggered when an error occurs during the swap phase
| [`htmx:targetError`](@/events.md#htmx:targetError)  | triggered when an invalid target is specified
| [`htmx:timeout`](@/events.md#htmx:timeout)  | triggered when a request timeout occurs
| [`htmx:validation:validate`](@/events.md#htmx:validation:validate)  | triggered before an element is validated
| [`htmx:validation:failed`](@/events.md#htmx:validation:failed)  | triggered when an element fails validation
| [`htmx:validation:halted`](@/events.md#htmx:validation:halted)  | triggered when a request is halted due to validation errors
| [`htmx:xhr:abort`](@/events.md#htmx:xhr:abort)  | triggered when an ajax request aborts
| [`htmx:xhr:loadend`](@/events.md#htmx:xhr:loadend)  | triggered when an ajax request ends
| [`htmx:xhr:loadstart`](@/events.md#htmx:xhr:loadstart)  | triggered when an ajax request starts
| [`htmx:xhr:progress`](@/events.md#htmx:xhr:progress)  | triggered periodically during an ajax request that supports progress events

&lt;/div&gt;

## JavaScript API Reference {#api}

&lt;div class=&quot;info-table&quot;&gt;

| Method | Description |
|-------|-------------|
| [`htmx.addClass()`](@/api.md#addClass)  | Adds a class to the given element
| [`htmx.ajax()`](@/api.md#ajax)  | Issues an htmx-style ajax request
| [`htmx.closest()`](@/api.md#closest)  | Finds the closest parent to the given element matching the selector
| [`htmx.config`](@/api.md#config)  | A property that holds the current htmx config object
| [`htmx.createEventSource`](@/api.md#createEventSource)  | A property holding the function to create SSE EventSource objects for htmx
| [`htmx.createWebSocket`](@/api.md#createWebSocket)  | A property holding the function to create WebSocket objects for htmx
| [`htmx.defineExtension()`](@/api.md#defineExtension)  | Defines an htmx [extension](https://extensions.htmx.org)
| [`htmx.find()`](@/api.md#find)  | Finds a single element matching the selector
| [`htmx.findAll()` `htmx.findAll(elt, selector)`](@/api.md#find)  | Finds all elements matching a given selector
| [`htmx.logAll()`](@/api.md#logAll)  | Installs a logger that will log all htmx events
| [`htmx.logger`](@/api.md#logger)  | A property set to the current logger (default is `null`)
| [`htmx.off()`](@/api.md#off)  | Removes an event listener from the given element
| [`htmx.on()`](@/api.md#on)  | Creates an event listener on the given element, returning it
| [`htmx.onLoad()`](@/api.md#onLoad)  | Adds a callback handler for the `htmx:load` event
| [`htmx.parseInterval()`](@/api.md#parseInterval)  | Parses an interval declaration into a millisecond value
| [`htmx.process()`](@/api.md#process)  | Processes the given element and its children, hooking up any htmx behavior
| [`htmx.remove()`](@/api.md#remove)  | Removes the given element
| [`htmx.removeClass()`](@/api.md#removeClass)  | Removes a class from the given element
| [`htmx.removeExtension()`](@/api.md#removeExtension)  | Removes an htmx [extension](https://extensions.htmx.org)
| [`htmx.swap()`](@/api.md#swap)  | Performs swapping (and settling) of HTML content
| [`htmx.takeClass()`](@/api.md#takeClass)  | Takes a class from other elements for the given element
| [`htmx.toggleClass()`](@/api.md#toggleClass)  | Toggles a class from the given element
| [`htmx.trigger()`](@/api.md#trigger)  | Triggers an event on an element
| [`htmx.values()`](@/api.md#values)  | Returns the input values associated with the given element

&lt;/div&gt;


## Configuration Reference {#config}

Htmx has some configuration options that can be accessed either programmatically or declaratively.  They are
listed below:

&lt;div class=&quot;info-table&quot;&gt;

| Config Variable                       | Info                                                                                                                                                                       |
|---------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `htmx.config.historyEnabled`          | defaults to `true`, really only useful for testing                                                                                                                         |
| `htmx.config.historyCacheSize`        | defaults to 10                                                                                                                                                             |
| `htmx.config.refreshOnHistoryMiss`    | defaults to `false`, if set to `true` htmx will issue a full page refresh on history misses rather than use an AJAX request                                                |
| `htmx.config.defaultSwapStyle`        | defaults to `innerHTML`                                                                                                                                                    |
| `htmx.config.defaultSwapDelay`        | defaults to 0                                                                                                                                                              |
| `htmx.config.defaultSettleDelay`      | defaults to 20                                                                                                                                                             |
| `htmx.config.includeIndicatorStyles`  | defaults to `true` (determines if the indicator styles are loaded)                                                                                                         |
| `htmx.config.indicatorClass`          | defaults to `htmx-indicator`                                                                                                                                               |
| `htmx.config.requestClass`            | defaults to `htmx-request`                                                                                                                                                 |
| `htmx.config.addedClass`              | defaults to `htmx-added`                                                                                                                                                   |
| `htmx.config.settlingClass`           | defaults to `htmx-settling`                                                                                                                                                |
| `htmx.config.swappingClass`           | defaults to `htmx-swapping`                                                                                                                                                |
| `htmx.config.allowEval`               | defaults to `true`, can be used to disable htmx&#x27;s use of eval for certain features (e.g. trigger filters)                                                                  |
| `htmx.config.allowScriptTags`         | defaults to `true`, determines if htmx will process script tags found in new content                                                                                       |
| `htmx.config.inlineScriptNonce`       | defaults to `&#x27;&#x27;`, meaning that no nonce will be added to inline scripts                                                                                                    |
| `htmx.config.inlineStyleNonce`        | defaults to `&#x27;&#x27;`, meaning that no nonce will be added to inline styles                                                                                                     |
| `htmx.config.attributesToSettle`      | defaults to `[&quot;class&quot;, &quot;style&quot;, &quot;width&quot;, &quot;height&quot;]`, the attributes to settle during the settling phase                                                                    |
| `htmx.config.wsReconnectDelay`        | defaults to `full-jitter`                                                                                                                                                  |
| `htmx.config.wsBinaryType`            | defaults to `blob`, the [the type of binary data](https://developer.mozilla.org/docs/Web/API/WebSocket/binaryType) being received over the WebSocket connection            |
| `htmx.config.disableSelector`         | defaults to `[hx-disable], [data-hx-disable]`, htmx will not process elements with this attribute on it or a parent                                                        |
| `htmx.config.withCredentials`         | defaults to `false`, allow cross-site Access-Control requests using credentials such as cookies, authorization headers or TLS client certificates                          |
| `htmx.config.timeout`                 | defaults to 0, the number of milliseconds a request can take before automatically being terminated                                                                         |
| `htmx.config.scrollBehavior`          | defaults to &#x27;instant&#x27;, the behavior for a boosted link on page transitions. The allowed values are `auto`, `instant` and `smooth`. Instant will scroll instantly in a single jump, smooth will scroll smoothly, while auto will behave like a vanilla link. |
| `htmx.config.defaultFocusScroll`      | if the focused element should be scrolled into view, defaults to false and can be overridden using the [focus-scroll](@/attributes/hx-swap.md#focus-scroll) swap modifier. |
| `htmx.config.getCacheBusterParam`     | defaults to false, if set to true htmx will append the target element to the `GET` request in the format `org.htmx.cache-buster=targetElementId`                           |
| `htmx.config.globalViewTransitions`   | if set to `true`, htmx will use the [View Transition](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API) API when swapping in new content.             |
| `htmx.config.methodsThatUseUrlParams` | defaults to `[&quot;get&quot;]`, htmx will format requests with these methods by encoding their parameters in the URL, not the request body                                          |
| `htmx.config.selfRequestsOnly`        | defaults to `true`, whether to only allow AJAX requests to the same domain as the current document                                                             |
| `htmx.config.ignoreTitle`             | defaults to `false`, if set to `true` htmx will not update the title of the document when a `title` tag is found in new content                                            |
| `htmx.config.scrollIntoViewOnBoost`   | defaults to `true`, whether or not the target of a boosted element is scrolled into the viewport. If `hx-target` is omitted on a boosted element, the target defaults to `body`, causing the page to scroll to the top. |
| `htmx.config.triggerSpecsCache`       | defaults to `null`, the cache to store evaluated trigger specifications into, improving parsing performance at the cost of more memory usage. You may define a simple object to use a never-clearing cache, or implement your own system using a [proxy object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy) |
| `htmx.config.allowNestedOobSwaps`     | defaults to `true`, whether to process OOB swaps on elements that are nested within the main response element. See [Nested OOB Swaps](@/attributes/hx-swap-oob.md#nested-oob-swaps). |

&lt;/div&gt;

You can set them directly in javascript, or you can use a `meta` tag:

```html
&lt;meta name=&quot;htmx-config&quot; content=&#x27;{&quot;defaultSwapStyle&quot;:&quot;outerHTML&quot;}&#x27;&gt;
```</doc>
  </docs>
  <examples>
    <doc title="Websockets application">from asyncio import sleep
from fasthtml.common import *

app = FastHTML(ws_hdr=True)
rt = app.route

def mk_inp(): return Input(id=&#x27;msg&#x27;)
nid = &#x27;notifications&#x27;

@rt(&#x27;/&#x27;)
async def get():
    cts = Div(
        Div(id=nid),
        Form(mk_inp(), id=&#x27;form&#x27;, ws_send=True),
        hx_ext=&#x27;ws&#x27;, ws_connect=&#x27;/ws&#x27;)
    return Titled(&#x27;Websocket Test&#x27;, cts)

async def on_connect(send): await send(Div(&#x27;Hello, you have connected&#x27;, id=nid))
async def on_disconnect( ): print(&#x27;Disconnected!&#x27;)

@app.ws(&#x27;/ws&#x27;, conn=on_connect, disconn=on_disconnect)
async def ws(msg:str, send):
    await send(Div(&#x27;Hello &#x27; + msg, id=nid))
    await sleep(2)
    return Div(&#x27;Goodbye &#x27; + msg, id=nid), mk_inp()

serve()
</doc>
    <doc title="Todo list application">###
# Walkthrough of an idiomatic fasthtml app
###

# This fasthtml app includes functionality from fastcore, starlette, fastlite, and fasthtml itself.
# Run with: `python adv_app.py`
# Importing from `fasthtml.common` brings the key parts of all of these together.
# For simplicity, you can just `from fasthtml.common import *`:
from fasthtml.common import *
# ...or you can import everything into a namespace:
# from fasthtml import common as fh
# ...or you can import each symbol explicitly (which we&#x27;re commenting out here but including for completeness):
&quot;&quot;&quot;
from fasthtml.common import (
    # These are the HTML components we use in this app
    A, AX, Button, Card, CheckboxX, Container, Div, Form, Grid, Group, H1, H2, Hidden, Input, Li, Main, Script, Style, Textarea, Title, Titled, Ul,
    # These are FastHTML symbols we&#x27;ll use
    Beforeware, FastHTML, fast_app, SortableJS, fill_form, picolink, serve,
    # These are from Starlette, Fastlite, fastcore, and the Python stdlib
    FileResponse, NotFoundError, RedirectResponse, database, patch, dataclass
)
&quot;&quot;&quot;

from hmac import compare_digest

# You can use any database you want; it&#x27;ll be easier if you pick a lib that supports the MiniDataAPI spec.
# Here we are using SQLite, with the FastLite library, which supports the MiniDataAPI spec.
db = database(&#x27;data/utodos.db&#x27;)
# The `t` attribute is the table collection. The `todos` and `users` tables are not created if they don&#x27;t exist.
# Instead, you can use the `create` method to create them if needed.
todos,users = db.t.todos,db.t.users
if todos not in db.t:
    # You can pass a dict, or kwargs, to most MiniDataAPI methods.
    users.create(dict(name=str, pwd=str), pk=&#x27;name&#x27;)
    todos.create(id=int, title=str, done=bool, name=str, details=str, priority=int, pk=&#x27;id&#x27;)
# Although you can just use dicts, it can be helpful to have types for your DB objects.
# The `dataclass` method creates that type, and stores it in the object, so it will use it for any returned items.
Todo,User = todos.dataclass(),users.dataclass()

# Any Starlette response class can be returned by a FastHTML route handler.
# In that case, FastHTML won&#x27;t change it at all.
# Status code 303 is a redirect that can change POST to GET, so it&#x27;s appropriate for a login page.
login_redir = RedirectResponse(&#x27;/login&#x27;, status_code=303)

# The `before` function is a *Beforeware* function. These are functions that run before a route handler is called.
def before(req, sess):
    # This sets the `auth` attribute in the request scope, and gets it from the session.
    # The session is a Starlette session, which is a dict-like object which is cryptographically signed,
    # so it can&#x27;t be tampered with.
    # The `auth` key in the scope is automatically provided to any handler which requests it, and can not
    # be injected by the user using query params, cookies, etc, so it should be secure to use.
    auth = req.scope[&#x27;auth&#x27;] = sess.get(&#x27;auth&#x27;, None)
    # If the session key is not there, it redirects to the login page.
    if not auth: return login_redir
    # `xtra` is part of the MiniDataAPI spec. It adds a filter to queries and DDL statements,
    # to ensure that the user can only see/edit their own todos.
    todos.xtra(name=auth)

markdown_js = &quot;&quot;&quot;
import { marked } from &quot;https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js&quot;;
import { proc_htmx} from &quot;https://cdn.jsdelivr.net/gh/answerdotai/fasthtml-js/fasthtml.js&quot;;
proc_htmx(&#x27;.markdown&#x27;, e =&gt; e.innerHTML = marked.parse(e.textContent));
&quot;&quot;&quot;

# We will use this in our `exception_handlers` dict
def _not_found(req, exc): return Titled(&#x27;Oh no!&#x27;, Div(&#x27;We could not find that page :(&#x27;))

# To create a Beforeware object, we pass the function itself, and optionally a list of regexes to skip.
bware = Beforeware(before, skip=[r&#x27;/favicon\.ico&#x27;, r&#x27;/static/.*&#x27;, r&#x27;.*\.css&#x27;, &#x27;/login&#x27;])
# The `FastHTML` class is a subclass of `Starlette`, so you can use any parameters that `Starlette` accepts.
# In addition, you can add your Beforeware here, and any headers you want included in HTML responses.
# FastHTML includes the &quot;HTMX&quot; and &quot;Surreal&quot; libraries in headers, unless you pass `default_hdrs=False`.
app = FastHTML(before=bware,
               # These are the same as Starlette exception_handlers, except they also support `FT` results
               exception_handlers={404: _not_found},
               # PicoCSS is a particularly simple CSS framework, with some basic integration built in to FastHTML.
               # `picolink` is pre-defined with the header for the PicoCSS stylesheet.
               # You can use any CSS framework you want, or none at all.
               hdrs=(picolink,
                     # `Style` is an `FT` object, which are 3-element lists consisting of:
                     # (tag_name, children_list, attrs_dict).
                     # FastHTML composes them from trees and auto-converts them to HTML when needed.
                     # You can also use plain HTML strings in handlers and headers,
                     # which will be auto-escaped, unless you use `NotStr(...string...)`.
                     Style(&#x27;:root { --pico-font-size: 100%; }&#x27;),
                     # Have a look at fasthtml/js.py to see how these Javascript libraries are added to FastHTML.
                     # They are only 5-10 lines of code each, and you can add your own too.
                     SortableJS(&#x27;.sortable&#x27;),
                     # MarkdownJS is actually provided as part of FastHTML, but we&#x27;ve included the js code here
                     # so that you can see how it works.
                     Script(markdown_js, type=&#x27;module&#x27;))
                )
# We add `rt` as a shortcut for `app.route`, which is what we&#x27;ll use to decorate our route handlers.
# When using `app.route` (or this shortcut), the only required argument is the path.
# The name of the decorated function (eg `get`, `post`, etc) is used as the HTTP verb for the handler.
rt = app.route

# For instance, this function handles GET requests to the `/login` path.
@rt(&quot;/login&quot;)
def get():
    # This creates a form with two input fields, and a submit button.
    # All of these components are `FT` objects. All HTML tags are provided in this form by FastHTML.
    # If you want other custom tags (e.g. `MyTag`), they can be auto-generated by e.g
    # `from fasthtml.components import MyTag`.
    # Alternatively, manually call e.g `ft(tag_name, *children, **attrs)`.
    frm = Form(
        # Tags with a `name` attr will have `name` auto-set to the same as `id` if not provided
        Input(id=&#x27;name&#x27;, placeholder=&#x27;Name&#x27;),
        Input(id=&#x27;pwd&#x27;, type=&#x27;password&#x27;, placeholder=&#x27;Password&#x27;),
        Button(&#x27;login&#x27;),
        action=&#x27;/login&#x27;, method=&#x27;post&#x27;)
    # If a user visits the URL directly, FastHTML auto-generates a full HTML page.
    # However, if the URL is accessed by HTMX, then one HTML partial is created for each element of the tuple.
    # To avoid this auto-generation of a full page, return a `HTML` object, or a Starlette `Response`.
    # `Titled` returns a tuple of a `Title` with the first arg and a `Container` with the rest.
    # See the comments for `Title` later for details.
    return Titled(&quot;Login&quot;, frm)

# Handlers are passed whatever information they &quot;request&quot; in the URL, as keyword arguments.
# Dataclasses, dicts, namedtuples, TypedDicts, and custom classes are automatically instantiated
# from form data.
# In this case, the `Login` class is a dataclass, so the handler will be passed `name` and `pwd`.
@dataclass
class Login: name:str; pwd:str

# This handler is called when a POST request is made to the `/login` path.
# The `login` argument is an instance of the `Login` class, which has been auto-instantiated from the form data.
# There are a number of special parameter names, which will be passed useful information about the request:
# `session`: the Starlette session; `request`: the Starlette request; `auth`: the value of `scope[&#x27;auth&#x27;]`,
# `htmx`: the HTMX headers, if any; `app`: the FastHTML app object.
# You can also pass any string prefix of `request` or `session`.
@rt(&quot;/login&quot;)
def post(login:Login, sess):
    if not login.name or not login.pwd: return login_redir
    # Indexing into a MiniDataAPI table queries by primary key, which is `name` here.
    # It returns a dataclass object, if `dataclass()` has been called at some point, or a dict otherwise.
    try: u = users[login.name]
    # If the primary key does not exist, the method raises a `NotFoundError`.
    # Here we use this to just generate a user -- in practice you&#x27;d probably to redirect to a signup page.
    except NotFoundError: u = users.insert(login)
    # This compares the passwords using a constant time string comparison
    # https://sqreen.github.io/DevelopersSecurityBestPractices/timing-attack/python
    if not compare_digest(u.pwd.encode(&quot;utf-8&quot;), login.pwd.encode(&quot;utf-8&quot;)): return login_redir
    # Because the session is signed, we can securely add information to it. It&#x27;s stored in the browser cookies.
    # If you don&#x27;t pass a secret signing key to `FastHTML`, it will auto-generate one and store it in a file `./sesskey`.
    sess[&#x27;auth&#x27;] = u.name
    return RedirectResponse(&#x27;/&#x27;, status_code=303)

# Instead of using `app.route` (or the `rt` shortcut), you can also use `app.get`, `app.post`, etc.
# In this case, the function name is not used to determine the HTTP verb.
@app.get(&quot;/logout&quot;)
def logout(sess):
    del sess[&#x27;auth&#x27;]
    return login_redir

# FastHTML uses Starlette&#x27;s path syntax, and adds a `static` type which matches standard static file extensions.
# You can define your own regex path specifiers -- for instance this is how `static` is defined in FastHTML
# `reg_re_param(&quot;static&quot;, &quot;ico|gif|jpg|jpeg|webm|css|js|woff|png|svg|mp4|webp|ttf|otf|eot|woff2|txt|xml|html&quot;)`
# In this app, we only actually have one static file, which is `favicon.ico`. But it would also be needed if
# we were referencing images, CSS/JS files, etc.
# Note, this function is unnecessary, as the `fast_app()` call already includes this functionality.
# However, it&#x27;s included here to show how you can define your own static file handler.
@rt(&quot;/{fname:path}.{ext:static}&quot;)
async def get(fname:str, ext:str): return FileResponse(f&#x27;{fname}.{ext}&#x27;)

# The `patch` decorator, which is defined in `fastcore`, adds a method to an existing class.
# Here we are adding a method to the `Todo` class, which is returned by the `todos` table.
# The `__ft__` method is a special method that FastHTML uses to convert the object into an `FT` object,
# so that it can be composed into an FT tree, and later rendered into HTML.
@patch
def __ft__(self:Todo):
    # Some FastHTML tags have an &#x27;X&#x27; suffix, which means they&#x27;re &quot;extended&quot; in some way.
    # For instance, here `AX` is an extended `A` tag, which takes 3 positional arguments:
    # `(text, hx_get, target_id)`.
    # All underscores in FT attrs are replaced with hyphens, so this will create an `hx-get` attr,
    # which HTMX uses to trigger a GET request.
    # Generally, most of your route handlers in practice (as in this demo app) are likely to be HTMX handlers.
    # For instance, for this demo, we only have two full-page handlers: the &#x27;/login&#x27; and &#x27;/&#x27; GET handlers.
    show = AX(self.title, f&#x27;/todos/{self.id}&#x27;, &#x27;current-todo&#x27;)
    edit = AX(&#x27;edit&#x27;,     f&#x27;/edit/{self.id}&#x27; , &#x27;current-todo&#x27;)
    dt = &#x27;✅ &#x27; if self.done else &#x27;&#x27;
    # FastHTML provides some shortcuts. For instance, `Hidden` is defined as simply:
    # `return Input(type=&quot;hidden&quot;, value=value, **kwargs)`
    cts = (dt, show, &#x27; | &#x27;, edit, Hidden(id=&quot;id&quot;, value=self.id), Hidden(id=&quot;priority&quot;, value=&quot;0&quot;))
    # Any FT object can take a list of children as positional args, and a dict of attrs as keyword args.
    return Li(*cts, id=f&#x27;todo-{self.id}&#x27;)

# This is the handler for the main todo list application.
# By including the `auth` parameter, it gets passed the current username, for displaying in the title.
@rt(&quot;/&quot;)
def get(auth):
    title = f&quot;{auth}&#x27;s Todo list&quot;
    top = Grid(H1(title), Div(A(&#x27;logout&#x27;, href=&#x27;/logout&#x27;), style=&#x27;text-align: right&#x27;))
    # We don&#x27;t normally need separate &quot;screens&quot; for adding or editing data. Here for instance,
    # we&#x27;re using an `hx-post` to add a new todo, which is added to the start of the list (using &#x27;afterbegin&#x27;).
    new_inp = Input(id=&quot;new-title&quot;, name=&quot;title&quot;, placeholder=&quot;New Todo&quot;)
    add = Form(Group(new_inp, Button(&quot;Add&quot;)),
               hx_post=&quot;/&quot;, target_id=&#x27;todo-list&#x27;, hx_swap=&quot;afterbegin&quot;)
    # In the MiniDataAPI spec, treating a table as a callable (i.e with `todos(...)` here) queries the table.
    # Because we called `xtra` in our Beforeware, this queries the todos for the current user only.
    # We can include the todo objects directly as children of the `Form`, because the `Todo` class has `__ft__` defined.
    # This is automatically called by FastHTML to convert the `Todo` objects into `FT` objects when needed.
    # The reason we put the todo list inside a form is so that we can use the &#x27;sortable&#x27; js library to reorder them.
    # That library calls the js `end` event when dragging is complete, so our trigger here causes our `/reorder`
    # handler to be called.
    frm = Form(*todos(order_by=&#x27;priority&#x27;),
               id=&#x27;todo-list&#x27;, cls=&#x27;sortable&#x27;, hx_post=&quot;/reorder&quot;, hx_trigger=&quot;end&quot;)
    # We create an empty &#x27;current-todo&#x27; Div at the bottom of our page, as a target for the details and editing views.
    card = Card(Ul(frm), header=add, footer=Div(id=&#x27;current-todo&#x27;))
    # PicoCSS uses `&lt;Main class=&#x27;container&#x27;&gt;` page content; `Container` is a tiny function that generates that.
    # A handler can return either a single `FT` object or string, or a tuple of them.
    # In the case of a tuple, the stringified objects are concatenated and returned to the browser.
    # The `Title` tag has a special purpose: it sets the title of the page.
    return Title(title), Container(top, card)

# This is the handler for the reordering of todos.
# It&#x27;s a POST request, which is used by the &#x27;sortable&#x27; js library.
# Because the todo list form created earlier included hidden inputs with the todo IDs,
# they are passed as form data. By using a parameter called (e.g) &quot;id&quot;, FastHTML will try to find
# something suitable in the request with this name. In order, it searches as follows:
# path; query; cookies; headers; session keys; form data.
# Although all these are provided in the request as strings, FastHTML will use your parameter&#x27;s type
# annotation to try to cast the value to the requested type.
# In the case of form data, there can be multiple values with the same key. So in this case,
# the parameter is a list of ints.
@rt(&quot;/reorder&quot;)
def post(id:list[int]):
    for i,id_ in enumerate(id): todos.update({&#x27;priority&#x27;:i}, id_)
    # HTMX by default replaces the inner HTML of the calling element, which in this case is the todo list form.
    # Therefore, we return the list of todos, now in the correct order, which will be auto-converted to FT for us.
    # In this case, it&#x27;s not strictly necessary, because sortable.js has already reorder the DOM elements.
    # However, by returning the updated data, we can be assured that there aren&#x27;t sync issues between the DOM
    # and the server.
    return tuple(todos(order_by=&#x27;priority&#x27;))

# Refactoring components in FastHTML is as simple as creating Python functions.
# The `clr_details` function creates a Div with specific HTMX attributes.
# `hx_swap_oob=&#x27;innerHTML&#x27;` tells HTMX to swap the inner HTML of the target element out-of-band,
# meaning it will update this element regardless of where the HTMX request originated from.
def clr_details(): return Div(hx_swap_oob=&#x27;innerHTML&#x27;, id=&#x27;current-todo&#x27;)

# This route handler uses a path parameter `{id}` which is automatically parsed and passed as an int.
@rt(&quot;/todos/{id}&quot;)
def delete(id:int):
    # The `delete` method is part of the MiniDataAPI spec, removing the item with the given primary key.
    todos.delete(id)
    # Returning `clr_details()` ensures the details view is cleared after deletion,
    # leveraging HTMX&#x27;s out-of-band swap feature.
    # Note that we are not returning *any* FT component that doesn&#x27;t have an &quot;OOB&quot; swap, so the target element
    # inner HTML is simply deleted. That&#x27;s why the deleted todo is removed from the list.
    return clr_details()

@rt(&quot;/edit/{id}&quot;)
async def get(id:int):
    # The `hx_put` attribute tells HTMX to send a PUT request when the form is submitted.
    # `target_id` specifies which element will be updated with the server&#x27;s response.
    res = Form(Group(Input(id=&quot;title&quot;), Button(&quot;Save&quot;)),
        Hidden(id=&quot;id&quot;), CheckboxX(id=&quot;done&quot;, label=&#x27;Done&#x27;),
        Textarea(id=&quot;details&quot;, name=&quot;details&quot;, rows=10),
        hx_put=&quot;/&quot;, target_id=f&#x27;todo-{id}&#x27;, id=&quot;edit&quot;)
    # `fill_form` populates the form with existing todo data, and returns the result.
    # Indexing into a table (`todos`) queries by primary key, which is `id` here. It also includes
    # `xtra`, so this will only return the id if it belongs to the current user.
    return fill_form(res, todos[id])

@rt(&quot;/&quot;)
async def put(todo: Todo):
    # `update` is part of the MiniDataAPI spec.
    # Note that the updated todo is returned. By returning the updated todo, we can update the list directly.
    # Because we return a tuple with `clr_details()`, the details view is also cleared.
    return todos.update(todo), clr_details()

@rt(&quot;/&quot;)
async def post(todo:Todo):
    # `hx_swap_oob=&#x27;true&#x27;` tells HTMX to perform an out-of-band swap, updating this element wherever it appears.
    # This is used to clear the input field after adding the new todo.
    new_inp =  Input(id=&quot;new-title&quot;, name=&quot;title&quot;, placeholder=&quot;New Todo&quot;, hx_swap_oob=&#x27;true&#x27;)
    # `insert` returns the inserted todo, which is appended to the start of the list, because we used
    # `hx_swap=&#x27;afterbegin&#x27;` when creating the todo list form.
    return todos.insert(todo), new_inp

@rt(&quot;/todos/{id}&quot;)
async def get(id:int):
    todo = todos[id]
    # `hx_swap` determines how the update should occur. We use &quot;outerHTML&quot; to replace the entire todo `Li` element.
    btn = Button(&#x27;delete&#x27;, hx_delete=f&#x27;/todos/{todo.id}&#x27;,
                 target_id=f&#x27;todo-{todo.id}&#x27;, hx_swap=&quot;outerHTML&quot;)
    # The &quot;markdown&quot; class is used here because that&#x27;s the CSS selector we used in the JS earlier.
    # Therefore this will trigger the JS to parse the markdown in the details field.
    # Because `class` is a reserved keyword in Python, we use `cls` instead, which FastHTML auto-converts.
    return Div(H2(todo.title), Div(todo.details, cls=&quot;markdown&quot;), btn)

serve()</doc>
  </examples>
</project>
"""

css_text = '''
    [contenteditable]:focus {
        outline: 0px solid transparent;
    }
    .flex-container {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 2rem;
    }
    .flex-item {
        flex: 1;
        box-sizing: border-box;
    }
    .code-output {
        height:50vh;
        padding: 1rem;
        overflow-y: auto;
        margin-bottom: 1rem;
    }
    .spinner {
        display: none;
    }
    .spinner.visible {
        display: block;
    }
    .file-content {
        max-height: 50vh; 
        min-height: 500px;
        height: 100vh;
        margin-top: 1rem;
        padding: 1rem;
        max-width: 40vw;
        overflow-x: auto;
        overflow-y: auto;
    }
    .file-content.hidden {
        display: none;
    }
    pre {
        background: transparent !important;
        //height: 28px !important;
        overflow: hidden !important;
        width: fit-content;
    }
    pre>code {
        display: inline-block !important;
        padding: 0 !important;
    }
   .mockup-code pre:before {
       margin-right: 0;
       width: 0;
   }
   h1 {
       font-size: var(--pico-font-size) !important;
       margin-bottom: 1rem !important;
       font-weight: 400 !important;
       padding: 2vh !important;
   }
   .toggle{
       width: 3rem !important;
       height: 1.5rem !important;
   }
 
)
'''


htmx_context="""
AJAX
The core of htmx is a set of attributes that allow you to issue AJAX requests directly from HTML:

Attribute	Description
hx-get	Issues a GET request to the given URL
hx-post	Issues a POST request to the given URL
hx-put	Issues a PUT request to the given URL
hx-patch	Issues a PATCH request to the given URL
hx-delete	Issues a DELETE request to the given URL
Each of these attributes takes a URL to issue an AJAX request to. The element will issue a request of the specified type to the given URL when the element is triggered:

<button hx-put="/messages">
    Put To Messages
</button>
This tells the browser:

When a user clicks on this button, issue a PUT request to the URL /messages and load the response into the button

#Triggering Requests
By default, AJAX requests are triggered by the “natural” event of an element:

input, textarea & select are triggered on the change event
form is triggered on the submit event
everything else is triggered by the click event
If you want different behavior you can use the hx-trigger attribute to specify which event will cause the request.

Here is a div that posts to /mouse_entered when a mouse enters it:

<div hx-post="/mouse_entered" hx-trigger="mouseenter">
    [Here Mouse, Mouse!]
</div>
#Trigger Modifiers
A trigger can also have a few additional modifiers that change its behavior. For example, if you want a request to only happen once, you can use the once modifier for the trigger:

<div hx-post="/mouse_entered" hx-trigger="mouseenter once">
    [Here Mouse, Mouse!]
</div>
Other modifiers you can use for triggers are:

changed - only issue a request if the value of the element has changed
delay:<time interval> - wait the given amount of time (e.g. 1s) before issuing the request. If the event triggers again, the countdown is reset.
throttle:<time interval> - wait the given amount of time (e.g. 1s) before issuing the request. Unlike delay if a new event occurs before the time limit is hit the event will be discarded, so the request will trigger at the end of the time period.
from:<CSS Selector> - listen for the event on a different element. This can be used for things like keyboard shortcuts. Note that this CSS selector is not re-evaluated if the page changes.
You can use these attributes to implement many common UX patterns, such as Active Search:

<input type="text" name="q"
    hx-get="/trigger_delay"
    hx-trigger="keyup changed delay:500ms"
    hx-target="#search-results"
    placeholder="Search..."
>
<div id="search-results"></div>
This input will issue a request 500 milliseconds after a key up event if the input has been changed and inserts the results into the div with the id search-results.

Multiple triggers can be specified in the hx-trigger attribute, separated by commas.

#Trigger Filters
You may also apply trigger filters by using square brackets after the event name, enclosing a javascript expression that will be evaluated. If the expression evaluates to true the event will trigger, otherwise it will not.

Here is an example that triggers only on a Control-Click of the element

<div hx-get="/clicked" hx-trigger="click[ctrlKey]">
    Control Click Me
</div>
Properties like ctrlKey will be resolved against the triggering event first, then against the global scope. The this symbol will be set to the current element.

#Special Events
htmx provides a few special events for use in hx-trigger:

load - fires once when the element is first loaded
revealed - fires once when an element first scrolls into the viewport
intersect - fires once when an element first intersects the viewport. This supports two additional options:
root:<selector> - a CSS selector of the root element for intersection
threshold:<float> - a floating point number between 0.0 and 1.0, indicating what amount of intersection to fire the event on
You can also use custom events to trigger requests if you have an advanced use case.

#Polling
If you want an element to poll the given URL rather than wait for an event, you can use the every syntax with the hx-trigger attribute:

<div hx-get="/news" hx-trigger="every 2s"></div>
This tells htmx

Every 2 seconds, issue a GET to /news and load the response into the div

If you want to stop polling from a server response you can respond with the HTTP response code 286 and the element will cancel the polling.

#Load Polling
Another technique that can be used to achieve polling in htmx is “load polling”, where an element specifies a load trigger along with a delay, and replaces itself with the response:

<div hx-get="/messages"
    hx-trigger="load delay:1s"
    hx-swap="outerHTML"
>
</div>
If the /messages end point keeps returning a div set up this way, it will keep “polling” back to the URL every second.

Load polling can be useful in situations where a poll has an end point at which point the polling terminates, such as when you are showing the user a progress bar.

#Request Indicators
When an AJAX request is issued it is often good to let the user know that something is happening since the browser will not give them any feedback. You can accomplish this in htmx by using htmx-indicator class.

The htmx-indicator class is defined so that the opacity of any element with this class is 0 by default, making it invisible but present in the DOM.

When htmx issues a request, it will put a htmx-request class onto an element (either the requesting element or another element, if specified). The htmx-request class will cause a child element with the htmx-indicator class on it to transition to an opacity of 1, showing the indicator.

<button hx-get="/click">
    Click Me!
    <img class="htmx-indicator" src="/spinner.gif">
</button>
Here we have a button. When it is clicked the htmx-request class will be added to it, which will reveal the spinner gif element. (I like SVG spinners these days.)

While the htmx-indicator class uses opacity to hide and show the progress indicator, if you would prefer another mechanism you can create your own CSS transition like so:

.htmx-indicator{
    display:none;
}
.htmx-request .htmx-indicator{
    display:inline;
}
.htmx-request.htmx-indicator{
    display:inline;
}
If you want the htmx-request class added to a different element, you can use the hx-indicator attribute with a CSS selector to do so:

<div>
    <button hx-get="/click" hx-indicator="#indicator">
        Click Me!
    </button>
    <img id="indicator" class="htmx-indicator" src="/spinner.gif"/>
</div>
Here we call out the indicator explicitly by id. Note that we could have placed the class on the parent div as well and had the same effect.

You can also add the disabled attribute to elements for the duration of a request by using the hx-disabled-elt attribute.

#Targets
If you want the response to be loaded into a different element other than the one that made the request, you can use the hx-target attribute, which takes a CSS selector. Looking back at our Live Search example:

<input type="text" name="q"
    hx-get="/trigger_delay"
    hx-trigger="keyup delay:500ms changed"
    hx-target="#search-results"
    placeholder="Search..."
>
<div id="search-results"></div>
You can see that the results from the search are going to be loaded into div#search-results, rather than into the input tag.

#Extended CSS Selectors
hx-target, and most attributes that take a CSS selector, support an “extended” CSS syntax:

You can use the this keyword, which indicates that the element that the hx-target attribute is on is the target
The closest <CSS selector> syntax will find the closest ancestor element or itself, that matches the given CSS selector. (e.g. closest tr will target the closest table row to the element)
The next <CSS selector> syntax will find the next element in the DOM matching the given CSS selector.
The previous <CSS selector> syntax will find the previous element in the DOM the given CSS selector.
find <CSS selector> which will find the first child descendant element that matches the given CSS selector. (e.g find tr would target the first child descendant row to the element)
In addition, a CSS selector may be wrapped in < and /> characters, mimicking the query literal syntax of hyperscript.

Relative targets like this can be useful for creating flexible user interfaces without peppering your DOM with lots of id attributes.

#Swapping
htmx offers a few different ways to swap the HTML returned into the DOM. By default, the content replaces the innerHTML of the target element. You can modify this by using the hx-swap attribute with any of the following values:

Name	Description
innerHTML
the default, puts the content inside the target element
outerHTML
replaces the entire target element with the returned content
afterbegin
prepends the content before the first child inside the target
beforebegin
prepends the content before the target in the target’s parent element
beforeend
appends the content after the last child inside the target
afterend
appends the content after the target in the target’s parent element
delete
deletes the target element regardless of the response
none
does not append content from response (Out of Band Swaps and Response Headers will still be processed)
#Morph Swaps
In addition to the standard swap mechanisms above, htmx also supports morphing swaps, via extensions. Morphing swaps attempt to merge new content into the existing DOM, rather than simply replacing it. They often do a better job preserving things like focus, video state, etc. by mutating existing nodes in-place during the swap operation, at the cost of more CPU.

The following extensions are available for morph-style swaps:

Idiomorph - A morphing algorithm created by the htmx developers.
Morphdom Swap - Based on the morphdom, the original DOM morphing library.
Alpine-morph - Based on the alpine morph plugin, plays well with alpine.js
#View Transitions
The new, experimental View Transitions API gives developers a way to create an animated transition between different DOM states. It is still in active development and is not available in all browsers, but htmx provides a way to work with this new API that falls back to the non-transition mechanism if the API is not available in a given browser.

You can experiment with this new API using the following approaches:

Set the htmx.config.globalViewTransitions config variable to true to use transitions for all swaps
Use the transition:true option in the hx-swap attribute
If an element swap is going to be transitioned due to either of the above configurations, you may catch the htmx:beforeTransition event and call preventDefault() on it to cancel the transition.
View Transitions can be configured using CSS, as outlined in the Chrome documentation for the feature.

You can see a view transition example on the Animation Examples page.

#Swap Options
The hx-swap attribute supports many options for tuning the swapping behavior of htmx. For example, by default htmx will swap in the title of a title tag found anywhere in the new content. You can turn this behavior off by setting the ignoreTitle modifier to true:

    <button hx-post="/like" hx-swap="outerHTML ignoreTitle:true">Like</button>
The modifiers available on hx-swap are:

Option	Description
transition
true or false, whether to use the view transition API for this swap
swap
The swap delay to use (e.g. 100ms) between when old content is cleared and the new content is inserted
settle
The settle delay to use (e.g. 100ms) between when new content is inserted and when it is settled
ignoreTitle
If set to true, any title found in the new content will be ignored and not update the document title
scroll
top or bottom, will scroll the target element to its top or bottom
show
top or bottom, will scroll the target element’s top or bottom into view
All swap modifiers appear after the swap style is specified, and are colon-separated.

See the hx-swap documentation for more details on these options.

#Synchronization
Often you want to coordinate the requests between two elements. For example, you may want a request from one element to supersede the request of another element, or to wait until the other element’s request has finished.

htmx offers a hx-sync attribute to help you accomplish this.

Consider a race condition between a form submission and an individual input’s validation request in this HTML:

<form hx-post="/store">
    <input id="title" name="title" type="text"
        hx-post="/validate"
        hx-trigger="change">
    <button type="submit">Submit</button>
</form>
Without using hx-sync, filling out the input and immediately submitting the form triggers two parallel requests to /validate and /store.

Using hx-sync="closest form:abort" on the input will watch for requests on the form and abort the input’s request if a form request is present or starts while the input request is in flight:

<form hx-post="/store">
    <input id="title" name="title" type="text"
        hx-post="/validate"
        hx-trigger="change"
        hx-sync="closest form:abort">
    <button type="submit">Submit</button>
</form>
This resolves the synchronization between the two elements in a declarative way.

htmx also supports a programmatic way to cancel requests: you can send the htmx:abort event to an element to cancel any in-flight requests:

<button id="request-button" hx-post="/example">
    Issue Request
</button>
<button onclick="htmx.trigger('#request-button', 'htmx:abort')">
    Cancel Request
</button>
More examples and details can be found on the hx-sync attribute page.

#CSS Transitions
htmx makes it easy to use CSS Transitions without javascript. Consider this HTML content:

<div id="div1">Original Content</div>
Imagine this content is replaced by htmx via an ajax request with this new content:

<div id="div1" class="red">New Content</div>
Note two things:

The div has the same id in the original and in the new content
The red class has been added to the new content
Given this situation, we can write a CSS transition from the old state to the new state:

.red {
    color: red;
    transition: all ease-in 1s ;
}
When htmx swaps in this new content, it will do so in such a way that the CSS transition will apply to the new content, giving you a nice, smooth transition to the new state.

So, in summary, all you need to do to use CSS transitions for an element is keep its id stable across requests!

You can see the Animation Examples for more details and live demonstrations.

#Details
To understand how CSS transitions actually work in htmx, you must understand the underlying swap & settle model that htmx uses.

When new content is received from a server, before the content is swapped in, the existing content of the page is examined for elements that match by the id attribute. If a match is found for an element in the new content, the attributes of the old content are copied onto the new element before the swap occurs. The new content is then swapped in, but with the old attribute values. Finally, the new attribute values are swapped in, after a “settle” delay (20ms by default). A little crazy, but this is what allows CSS transitions to work without any javascript by the developer.

#Out of Band Swaps
If you want to swap content from a response directly into the DOM by using the id attribute you can use the hx-swap-oob attribute in the response html:

<div id="message" hx-swap-oob="true">Swap me directly!</div>
Additional Content
In this response, div#message would be swapped directly into the matching DOM element, while the additional content would be swapped into the target in the normal manner.

You can use this technique to “piggy-back” updates on other requests.

#Troublesome Tables
Table elements can be problematic when combined with out of band swaps, because, by the HTML spec, many can’t stand on their own in the DOM (e.g. <tr> or <td>).

To avoid this issue you can use a template tag to encapsulate these elements:

<template>
  <tr id="message" hx-swap-oob="true"><td>Joe</td><td>Smith</td></tr>
</template>
#Selecting Content To Swap
If you want to select a subset of the response HTML to swap into the target, you can use the hx-select attribute, which takes a CSS selector and selects the matching elements from the response.

You can also pick out pieces of content for an out-of-band swap by using the hx-select-oob attribute, which takes a list of element IDs to pick out and swap.

#Preserving Content During A Swap
If there is content that you wish to be preserved across swaps (e.g. a video player that you wish to remain playing even if a swap occurs) you can use the hx-preserve attribute on the elements you wish to be preserved.

#Parameters
By default, an element that causes a request will include its value if it has one. If the element is a form it will include the values of all inputs within it.

As with HTML forms, the name attribute of the input is used as the parameter name in the request that htmx sends.

Additionally, if the element causes a non-GET request, the values of all the inputs of the nearest enclosing form will be included.

If you wish to include the values of other elements, you can use the hx-include attribute with a CSS selector of all the elements whose values you want to include in the request.

If you wish to filter out some parameters you can use the hx-params attribute.

Finally, if you want to programmatically modify the parameters, you can use the htmx:configRequest event.

#File Upload
If you wish to upload files via an htmx request, you can set the hx-encoding attribute to multipart/form-data. This will use a FormData object to submit the request, which will properly include the file in the request.

Note that depending on your server-side technology, you may have to handle requests with this type of body content very differently.

Note that htmx fires a htmx:xhr:progress event periodically based on the standard progress event during upload, which you can hook into to show the progress of the upload.

See the examples section for more advanced form patterns, including progress bars and error handling.

#Extra Values
You can include extra values in a request using the hx-vals (name-expression pairs in JSON format) and hx-vars attributes (comma-separated name-expression pairs that are dynamically computed).

#Confirming Requests
Often you will want to confirm an action before issuing a request. htmx supports the hx-confirm attribute, which allows you to confirm an action using a simple javascript dialog:

<button hx-delete="/account" hx-confirm="Are you sure you wish to delete your account?">
    Delete My Account
</button>
Using events you can implement more sophisticated confirmation dialogs. The confirm example shows how to use sweetalert2 library for confirmation of htmx actions.

#Confirming Requests Using Events
Another option to do confirmation with is via the htmx:confirm event event. This event is fired on every trigger for a request (not just on elements that have a hx-confirm attribute) and can be used to implement asynchronous confirmation of the request.

Here is an example using sweet alert on any element with a confirm-with-sweet-alert='true' attribute on it:

document.body.addEventListener('htmx:confirm', function(evt) {
  if (evt.target.matches("[confirm-with-sweet-alert='true']")) {
    evt.preventDefault();
    swal({
      title: "Are you sure?",
      text: "Are you sure you are sure?",
      icon: "warning",
      buttons: true,
      dangerMode: true,
    }).then((confirmed) => {
      if (confirmed) {
        evt.detail.issueRequest();
      }
    });     
  }
});
#Attribute Inheritance
Most attributes in htmx are inherited: they apply to the element they are on as well as any children elements. This allows you to “hoist” attributes up the DOM to avoid code duplication. Consider the following htmx:

<button hx-delete="/account" hx-confirm="Are you sure?">
    Delete My Account
</button>
<button hx-put="/account" hx-confirm="Are you sure?">
    Update My Account
</button>
Here we have a duplicate hx-confirm attribute. We can hoist this attribute to a parent element:

<div hx-confirm="Are you sure?">
    <button hx-delete="/account">
        Delete My Account
    </button>
    <button hx-put="/account">
        Update My Account
    </button>
</div>
This hx-confirm attribute will now apply to all htmx-powered elements within it.

Sometimes you wish to undo this inheritance. Consider if we had a cancel button to this group, but didn’t want it to be confirmed. We could add an unset directive on it like so:

<div hx-confirm="Are you sure?">
    <button hx-delete="/account">
        Delete My Account
    </button>
    <button hx-put="/account">
        Update My Account
    </button>
    <button hx-confirm="unset" hx-get="/">
        Cancel
    </button>
</div>
The top two buttons would then show a confirm dialog, but the bottom cancel button would not.

Inheritance can be disabled on a per-element and per-attribute basis using the hx-disinherit attribute.

If you wish to disable attribute inheritance entirely, you can set the htmx.config.disableInheritance configuration variable to true. This will disable inheritance as a default, and allow you to specify inheritance explicitly with the hx-inherit attribute.

#Boosting
Htmx supports “boosting” regular HTML anchors and forms with the hx-boost attribute. This attribute will convert all anchor tags and forms into AJAX requests that, by default, target the body of the page.

Here is an example:

<div hx-boost="true">
    <a href="/blog">Blog</a>
</div>
The anchor tag in this div will issue an AJAX GET request to /blog and swap the response into the body tag.

#Progressive Enhancement
A feature of hx-boost is that it degrades gracefully if javascript is not enabled: the links and forms continue to work, they simply don’t use ajax requests. This is known as Progressive Enhancement, and it allows a wider audience to use your site’s functionality.

Other htmx patterns can be adapted to achieve progressive enhancement as well, but they will require more thought.

Consider the active search example. As it is written, it will not degrade gracefully: someone who does not have javascript enabled will not be able to use this feature. This is done for simplicity’s sake, to keep the example as brief as possible.

However, you could wrap the htmx-enhanced input in a form element:

<form action="/search" method="POST">
    <input class="form-control" type="search"
        name="search" placeholder="Begin typing to search users..."
        hx-post="/search"
        hx-trigger="keyup changed delay:500ms, search"
        hx-target="#search-results"
        hx-indicator=".htmx-indicator">
</form>
With this in place, javascript-enabled clients would still get the nice active-search UX, but non-javascript enabled clients would be able to hit the enter key and still search. Even better, you could add a “Search” button as well. You would then need to update the form with an hx-post that mirrored the action attribute, or perhaps use hx-boost on it.

You would need to check on the server side for the HX-Request header to differentiate between an htmx-driven and a regular request, to determine exactly what to render to the client.

Other patterns can be adapted similarly to achieve the progressive enhancement needs of your application.

As you can see, this requires more thought and more work. It also rules some functionality entirely out of bounds. These tradeoffs must be made by you, the developer, with respect to your projects goals and audience.

Accessibility is a concept closely related to progressive enhancement. Using progressive enhancement techniques such as hx-boost will make your htmx application more accessible to a wide array of users.

htmx-based applications are very similar to normal, non-AJAX driven web applications because htmx is HTML-oriented.

As such, the normal HTML accessibility recommendations apply. For example:

Use semantic HTML as much as possible (i.e. the right tags for the right things)
Ensure focus state is clearly visible
Associate text labels with all form fields
Maximize the readability of your application with appropriate fonts, contrast, etc.
#Web Sockets & SSE
Web Sockets and Server Sent Events (SSE) are supported via extensions. Please see the SSE extension and WebSocket extension pages to learn more.

#History Support
Htmx provides a simple mechanism for interacting with the browser history API:

If you want a given element to push its request URL into the browser navigation bar and add the current state of the page to the browser’s history, include the hx-push-url attribute:

<a hx-get="/blog" hx-push-url="true">Blog</a>
When a user clicks on this link, htmx will snapshot the current DOM and store it before it makes a request to /blog. It then does the swap and pushes a new location onto the history stack.

When a user hits the back button, htmx will retrieve the old content from storage and swap it back into the target, simulating “going back” to the previous state. If the location is not found in the cache, htmx will make an ajax request to the given URL, with the header HX-History-Restore-Request set to true, and expects back the HTML needed for the entire page. Alternatively, if the htmx.config.refreshOnHistoryMiss config variable is set to true, it will issue a hard browser refresh.

NOTE: If you push a URL into the history, you must be able to navigate to that URL and get a full page back! A user could copy and paste the URL into an email, or new tab. Additionally, htmx will need the entire page when restoring history if the page is not in the history cache.

#Specifying History Snapshot Element
By default, htmx will use the body to take and restore the history snapshot from. This is usually the right thing, but if you want to use a narrower element for snapshotting you can use the hx-history-elt attribute to specify a different one.

Careful: this element will need to be on all pages or restoring from history won’t work reliably.

#Undoing DOM Mutations By 3rd Party Libraries
If you are using a 3rd party library and want to use the htmx history feature, you will need to clean up the DOM before a snapshot is taken. Let’s consider the Tom Select library, which makes select elements a much richer user experience. Let’s set up TomSelect to turn any input element with the .tomselect class into a rich select element.

First we need to initialize elements that have the class in new content:

htmx.onLoad(function (target) {
    // find all elements in the new content that should be
    // an editor and init w/ TomSelect
    var editors = target.querySelectorAll(".tomselect")
            .forEach(elt => new TomSelect(elt))
});
This will create a rich selector for all input elements that have the .tomselect class on it. However, it mutates the DOM and we don’t want that mutation saved to the history cache, since TomSelect will be reinitialized when the history content is loaded back into the screen.

To deal with this, we need to catch the htmx:beforeHistorySave event and clean out the TomSelect mutations by calling destroy() on them:

htmx.on('htmx:beforeHistorySave', function() {
    // find all TomSelect elements
    document.querySelectorAll('.tomSelect')
            .forEach(elt => elt.tomselect.destroy()) // and call destroy() on them
})
This will revert the DOM to the original HTML, thus allowing for a clean snapshot.

#Disabling History Snapshots
History snapshotting can be disabled for a URL by setting the hx-history attribute to false on any element in the current document, or any html fragment loaded into the current document by htmx. This can be used to prevent sensitive data entering the localStorage cache, which can be important for shared-use / public computers. History navigation will work as expected, but on restoration the URL will be requested from the server instead of the local history cache.

#Requests & Responses
Htmx expects responses to the AJAX requests it makes to be HTML, typically HTML fragments (although a full HTML document, matched with a hx-select tag can be useful too). Htmx will then swap the returned HTML into the document at the target specified and with the swap strategy specified.

Sometimes you might want to do nothing in the swap, but still perhaps trigger a client side event (see below).

For this situation, by default, you can return a 204 - No Content response code, and htmx will ignore the content of the response.

In the event of an error response from the server (e.g. a 404 or a 501), htmx will trigger the htmx:responseError event, which you can handle.

In the event of a connection error, the htmx:sendError htmx:sendError event will be triggered.

#Configuring Response Handling
You can configure the above behavior of htmx by mutating or replacing the htmx.config.responseHandling array. This object is a collection of JavaScript objects defined like so:

    responseHandling: [
        {code:"204", swap: false},   // 204 - No Content by default does nothing, but is not an error
        {code:"[23]..", swap: true}, // 200 & 300 responses are non-errors and are swapped
        {code:"[45]..", swap: false, error:true}, // 400 & 500 responses are not swapped and are errors
        {code:"...", swap: false}    // catch all for any other response code
    ]
When htmx receives a response it will iterate in order over the htmx.config.responseHandling array and test if the code property of a given object, when treated as a Regular Expression, matches the current response. If an entry does match the current response code, it will be used to determine if and how the response will be processed.

The fields available for response handling configuration on entries in this array are:

code - a String representing a regular expression that will be tested against response codes.
swap - true if the response should be swapped into the DOM, false otherwise
error - true if htmx should treat this response as an error
ignoreTitle - true if htmx should ignore title tags in the response
select - A CSS selector to use to select content from the response
target - A CSS selector specifying an alternative target for the response
swapOverride - An alternative swap mechanism for the response
#Configuring Response Handling Examples
As an example of how to use this configuration, consider a situation when a server-side framework responds with a 422 - Unprocessable Entity response when validation errors occur. By default, htmx will ignore the response, since it matches the Regular Expression [45]...

Using the meta config mechanism for configuring responseHandling, we could add the following config:

<!--
  * 204 No Content by default does nothing, but is not an error
  * 2xx, 3xx and 422 responses are non-errors and are swapped
  * 4xx & 5xx responses are not swapped and are errors
  * all other responses are swapped using "..." as a catch-all
-->
<meta
	name="htmx-config"
	content='{
        "responseHandling":[
            {"code":"204", "swap": false},
            {"code":"[23]..", "swap": true},
            {"code":"422", "swap": true},
            {"code":"[45]..", "swap": false, "error":true},
            {"code":"...", "swap": true}
        ]
    }'
/>
If you wanted to swap everything, regardless of HTTP response code, you could use this configuration:

<meta name="htmx-config" content='{"responseHandling": [{"code":".*", "swap": true}]}' /> <!--all responses are swapped-->
Finally, it is worth considering using the Response Targets extension, which allows you to configure the behavior of response codes declaratively via attributes.

#CORS
When using htmx in a cross origin context, remember to configure your web server to set Access-Control headers in order for htmx headers to be visible on the client side.

Access-Control-Allow-Headers (for request headers)
Access-Control-Expose-Headers (for response headers)
See all the request and response headers that htmx implements.

#Request Headers
htmx includes a number of useful headers in requests:

Header	Description
HX-Boosted
indicates that the request is via an element using hx-boost
HX-Current-URL
the current URL of the browser
HX-History-Restore-Request
“true” if the request is for history restoration after a miss in the local history cache
HX-Prompt
the user response to an hx-prompt
HX-Request
always “true”
HX-Target
the id of the target element if it exists
HX-Trigger-Name
the name of the triggered element if it exists
HX-Trigger
the id of the triggered element if it exists
#Response Headers
htmx supports some htmx-specific response headers:

HX-Location - allows you to do a client-side redirect that does not do a full page reload
HX-Push-Url - pushes a new url into the history stack
HX-Redirect - can be used to do a client-side redirect to a new location
HX-Refresh - if set to “true” the client-side will do a full refresh of the page
HX-Replace-Url - replaces the current URL in the location bar
HX-Reswap - allows you to specify how the response will be swapped. See hx-swap for possible values
HX-Retarget - a CSS selector that updates the target of the content update to a different element on the page
HX-Reselect - a CSS selector that allows you to choose which part of the response is used to be swapped in. Overrides an existing hx-select on the triggering element
HX-Trigger - allows you to trigger client-side events
HX-Trigger-After-Settle - allows you to trigger client-side events after the settle step
HX-Trigger-After-Swap - allows you to trigger client-side events after the swap step
For more on the HX-Trigger headers, see HX-Trigger Response Headers.

Submitting a form via htmx has the benefit of no longer needing the Post/Redirect/Get Pattern. After successfully processing a POST request on the server, you don’t need to return a HTTP 302 (Redirect). You can directly return the new HTML fragment.

#Request Order of Operations
The order of operations in a htmx request are:

The element is triggered and begins a request
Values are gathered for the request
The htmx-request class is applied to the appropriate elements
The request is then issued asynchronously via AJAX
Upon getting a response the target element is marked with the htmx-swapping class
An optional swap delay is applied (see the hx-swap attribute)
The actual content swap is done
the htmx-swapping class is removed from the target
the htmx-added class is added to each new piece of content
the htmx-settling class is applied to the target
A settle delay is done (default: 20ms)
The DOM is settled
the htmx-settling class is removed from the target
the htmx-added class is removed from each new piece of content
You can use the htmx-swapping and htmx-settling classes to create CSS transitions between pages.

#Validation
Htmx integrates with the HTML5 Validation API and will not issue a request for a form if a validatable input is invalid. This is true for both AJAX requests as well as WebSocket sends.

Htmx fires events around validation that can be used to hook in custom validation and error handling:

htmx:validation:validate - called before an element’s checkValidity() method is called. May be used to add in custom validation logic
htmx:validation:failed - called when checkValidity() returns false, indicating an invalid input
htmx:validation:halted - called when a request is not issued due to validation errors. Specific errors may be found in the event.detail.errors object
Non-form elements do not validate before they make requests by default, but you can enable validation by setting the hx-validate attribute to “true”.

#Validation Example
Here is an example of an input that uses the hx-on attribute to catch the htmx:validation:validate event and require that the input have the value foo:

<form id="example-form" hx-post="/test">
    <input name="example"
           onkeyup="this.setCustomValidity('') // reset the validation on keyup"
           hx-on:htmx:validation:validate="if(this.value != 'foo') {
                    this.setCustomValidity('Please enter the value foo') // set the validation error
                    htmx.find('#example-form').reportValidity()          // report the issue
                }">
</form>
Note that all client side validations must be re-done on the server side, as they can always be bypassed.

#Animations
Htmx allows you to use CSS transitions in many situations using only HTML and CSS.

Please see the Animation Guide for more details on the options available.

#Extensions
Htmx has an extension mechanism that allows you to customize the libraries’ behavior. Extensions are defined in javascript and then used via the hx-ext attribute:

<div hx-ext="debug">
    <button hx-post="/example">This button used the debug extension</button>
    <button hx-post="/example" hx-ext="ignore:debug">This button does not</button>
</div>
If you are interested in adding your own extension to htmx, please see the extension docs

#Events & Logging
Htmx has an extensive events mechanism, which doubles as the logging system.

If you want to register for a given htmx event you can use

document.body.addEventListener('htmx:load', function(evt) {
    myJavascriptLib.init(evt.detail.elt);
});
or, if you would prefer, you can use the following htmx helper:

htmx.on("htmx:load", function(evt) {
    myJavascriptLib.init(evt.detail.elt);
});
The htmx:load event is fired every time an element is loaded into the DOM by htmx, and is effectively the equivalent to the normal load event.

Some common uses for htmx events are:

#Initialize A 3rd Party Library With Events
Using the htmx:load event to initialize content is so common that htmx provides a helper function:

htmx.onLoad(function(target) {
    myJavascriptLib.init(target);
});
This does the same thing as the first example, but is a little cleaner.

#Configure a Request With Events
You can handle the htmx:configRequest event in order to modify an AJAX request before it is issued:

document.body.addEventListener('htmx:configRequest', function(evt) {
    evt.detail.parameters['auth_token'] = getAuthToken(); // add a new parameter into the request
    evt.detail.headers['Authentication-Token'] = getAuthToken(); // add a new header into the request
});
Here we add a parameter and header to the request before it is sent.

#Modifying Swapping Behavior With Events
You can handle the htmx:beforeSwap event in order to modify the swap behavior of htmx:

document.body.addEventListener('htmx:beforeSwap', function(evt) {
    if(evt.detail.xhr.status === 404){
        // alert the user when a 404 occurs (maybe use a nicer mechanism than alert())
        alert("Error: Could Not Find Resource");
    } else if(evt.detail.xhr.status === 422){
        // allow 422 responses to swap as we are using this as a signal that
        // a form was submitted with bad data and want to rerender with the
        // errors
        //
        // set isError to false to avoid error logging in console
        evt.detail.shouldSwap = true;
        evt.detail.isError = false;
    } else if(evt.detail.xhr.status === 418){
        // if the response code 418 (I'm a teapot) is returned, retarget the
        // content of the response to the element with the id `teapot`
        evt.detail.shouldSwap = true;
        evt.detail.target = htmx.find("#teapot");
    }
});
Here we handle a few 400-level error response codes that would normally not do a swap in htmx.

#Event Naming
Note that all events are fired with two different names

Camel Case
Kebab Case
So, for example, you can listen for htmx:afterSwap or for htmx:after-swap. This facilitates interoperability with other libraries. Alpine.js, for example, requires kebab case.

#Logging
If you set a logger at htmx.logger, every event will be logged. This can be very useful for troubleshooting:

htmx.logger = function(elt, event, data) {
    if(console) {
        console.log(event, elt, data);
    }
}
#Debugging
Declarative and event driven programming with htmx (or any other declarative language) can be a wonderful and highly productive activity, but one disadvantage when compared with imperative approaches is that it can be trickier to debug.

Figuring out why something isn’t happening, for example, can be difficult if you don’t know the tricks.

Well, here are the tricks:

The first debugging tool you can use is the htmx.logAll() method. This will log every event that htmx triggers and will allow you to see exactly what the library is doing.

htmx.logAll();
Of course, that won’t tell you why htmx isn’t doing something. You might also not know what events a DOM element is firing to use as a trigger. To address this, you can use the monitorEvents() method available in the browser console:

monitorEvents(htmx.find("#theElement"));
This will spit out all events that are occurring on the element with the id theElement to the console, and allow you to see exactly what is going on with it.

Note that this only works from the console, you cannot embed it in a script tag on your page.

Finally, push come shove, you might want to just debug htmx.js by loading up the unminimized version. It’s about 2500 lines of javascript, so not an insurmountable amount of code. You would most likely want to set a break point in the issueAjaxRequest() and handleAjaxResponse() methods to see what’s going on.

And always feel free to jump on the Discord if you need help.

#Creating Demos
Sometimes, in order to demonstrate a bug or clarify a usage, it is nice to be able to use a javascript snippet site like jsfiddle. To facilitate easy demo creation, htmx hosts a demo script site that will install:

htmx
hyperscript
a request mocking library
Simply add the following script tag to your demo/fiddle/whatever:

<script src="https://demo.htmx.org"></script>
This helper allows you to add mock responses by adding template tags with a url attribute to indicate which URL. The response for that url will be the innerHTML of the template, making it easy to construct mock responses. You can add a delay to the response with a delay attribute, which should be an integer indicating the number of milliseconds to delay

You may embed simple expressions in the template with the ${} syntax.

Note that this should only be used for demos and is in no way guaranteed to work for long periods of time as it will always be grabbing the latest versions htmx and hyperscript!

#Demo Example
Here is an example of the code in action:

<!-- load demo environment -->
<script src="https://demo.htmx.org"></script>

<!-- post to /foo -->
<button hx-post="/foo" hx-target="#result">
    Count Up
</button>
<output id="result"></output>

<!-- respond to /foo with some dynamic content in a template tag -->
<script>
    globalInt = 0;
</script>
<template url="/foo" delay="500"> <!-- note the url and delay attributes -->
    ${globalInt++}
</template>

#Scripting
While htmx encourages a hypermedia approach to building web applications, it offers many options for client scripting. Scripting is included in the REST-ful description of web architecture, see: Code-On-Demand. As much as is feasible, we recommend a hypermedia-friendly approach to scripting in your web application:

Respect HATEOAS
Use events to communicate between components
Use islands to isolate non-hypermedia components from the rest of your application
Consider inline scripting
The primary integration point between htmx and scripting solutions is the events that htmx sends and can respond to. See the SortableJS example in the 3rd Party Javascript section for a good template for integrating a JavaScript library with htmx via events.

Scripting solutions that pair well with htmx include:

VanillaJS - Simply using the built-in abilities of JavaScript to hook in event handlers to respond to the events htmx emits can work very well for scripting. This is an extremely lightweight and increasingly popular approach.
AlpineJS - Alpine.js provides a rich set of tools for creating sophisticated front end scripts, including reactive programming support, while still remaining extremely lightweight. Alpine encourages the “inline scripting” approach that we feel pairs well with htmx.
jQuery - Despite its age and reputation in some circles, jQuery pairs very well with htmx, particularly in older code-bases that already have a lot of jQuery in them.
hyperscript - Hyperscript is an experimental front-end scripting language created by the same team that created htmx. It is designed to embed well in HTML and both respond to and create events, and pairs very well with htmx.
We have an entire chapter entitled “Client-Side Scripting” in our book that looks at how scripting can be integrated into your htmx-based application.

#The hx-on* Attributes
HTML allows the embedding of inline scripts via the onevent properties, such as onClick:

<button onclick="alert('You clicked me!')">
    Click Me!
</button>
This feature allows scripting logic to be co-located with the HTML elements the logic applies to, giving good Locality of Behaviour (LoB). Unfortunately, HTML only allows on* attributes for a fixed number of specific DOM events (e.g. onclick) and doesn’t provide a generalized mechanism for responding to arbitrary events on elements.

In order to address this shortcoming, htmx offers hx-on* attributes. These attributes allow you to respond to any event in a manner that preserves the LoB of the standard on* properties.

If we wanted to respond to the click event using an hx-on attribute, we would write this:

<button hx-on:click="alert('You clicked me!')">
    Click Me!
</button>
So, the string hx-on, followed by a colon (or a dash), then by the name of the event.

For a click event, of course, we would recommend sticking with the standard onclick attribute. However, consider an htmx-powered button that wishes to add a parameter to a request using the htmx:config-request event. This would not be possible using a standard on* property, but it can be done using the hx-on:htmx:config-request attribute:

<button hx-post="/example"
        hx-on:htmx:config-request="event.detail.parameters.example = 'Hello Scripting!'">
    Post Me!
</button>
Here the example parameter is added to the POST request before it is issued, with the value ‘Hello Scripting!’.

The hx-on* attributes are a very simple mechanism for generalized embedded scripting. It is not a replacement for more fully developed front-end scripting solutions such as AlpineJS or hyperscript. It can, however, augment a VanillaJS-based approach to scripting in your htmx-powered application.

Note that HTML attributes are case insensitive. This means that, unfortunately, events that rely on capitalization/ camel casing, cannot be responded to. If you need to support camel case events we recommend using a more fully functional scripting solution such as AlpineJS or hyperscript. htmx dispatches all its events in both camelCase and in kebab-case for this very reason.

#3rd Party Javascript
Htmx integrates fairly well with third party libraries. If the library fires events on the DOM, you can use those events to trigger requests from htmx.

A good example of this is the SortableJS demo:

<form class="sortable" hx-post="/items" hx-trigger="end">
    <div class="htmx-indicator">Updating...</div>
    <div><input type='hidden' name='item' value='1'/>Item 1</div>
    <div><input type='hidden' name='item' value='2'/>Item 2</div>
    <div><input type='hidden' name='item' value='2'/>Item 3</div>
</form>
With Sortable, as with most javascript libraries, you need to initialize content at some point.

In jquery you might do this like so:

$(document).ready(function() {
    var sortables = document.body.querySelectorAll(".sortable");
    for (var i = 0; i < sortables.length; i++) {
        var sortable = sortables[i];
        new Sortable(sortable, {
            animation: 150,
            ghostClass: 'blue-background-class'
        });
    }
});
In htmx, you would instead use the htmx.onLoad function, and you would select only from the newly loaded content, rather than the entire document:

htmx.onLoad(function(content) {
    var sortables = content.querySelectorAll(".sortable");
    for (var i = 0; i < sortables.length; i++) {
        var sortable = sortables[i];
        new Sortable(sortable, {
            animation: 150,
            ghostClass: 'blue-background-class'
        });
    }
})
This will ensure that as new content is added to the DOM by htmx, sortable elements are properly initialized.

If javascript adds content to the DOM that has htmx attributes on it, you need to make sure that this content is initialized with the htmx.process() function.

For example, if you were to fetch some data and put it into a div using the fetch API, and that HTML had htmx attributes in it, you would need to add a call to htmx.process() like this:

let myDiv = document.getElementById('my-div')
fetch('http://example.com/movies.json')
    .then(response => response.text())
    .then(data => { myDiv.innerHTML = data; htmx.process(myDiv); } );
Some 3rd party libraries create content from HTML template elements. For instance, Alpine JS uses the x-if attribute on templates to add content conditionally. Such templates are not initially part of the DOM and, if they contain htmx attributes, will need a call to htmx.process() after they are loaded. The following example uses Alpine’s $watch function to look for a change of value that would trigger conditional content:

<div x-data="{show_new: false}"
    x-init="$watch('show_new', value => {
        if (show_new) {
            htmx.process(document.querySelector('#new_content'))
        }
    })">
    <button @click = "show_new = !show_new">Toggle New Content</button>
    <template x-if="show_new">
        <div id="new_content">
            <a hx-get="/server/newstuff" href="#">New Clickable</a>
        </div>
    </template>
</div>
#Web Components
Please see the Web Components Examples page for examples on how to integrate htmx with web components.

#Caching
htmx works with standard HTTP caching mechanisms out of the box.

If your server adds the Last-Modified HTTP response header to the response for a given URL, the browser will automatically add the If-Modified-Since request HTTP header to the next requests to the same URL. Be mindful that if your server can render different content for the same URL depending on some other headers, you need to use the Vary response HTTP header. For example, if your server renders the full HTML when the HX-Request header is missing or false, and it renders a fragment of that HTML when HX-Request: true, you need to add Vary: HX-Request. That causes the cache to be keyed based on a composite of the response URL and the HX-Request request header — rather than being based just on the response URL.

If you are unable (or unwilling) to use the Vary header, you can alternatively set the configuration parameter getCacheBusterParam to true. If this configuration variable is set, htmx will include a cache-busting parameter in GET requests that it makes, which will prevent browsers from caching htmx-based and non-htmx based responses in the same cache slot.

htmx also works with ETag as expected. Be mindful that if your server can render different content for the same URL (for example, depending on the value of the HX-Request header), the server needs to generate a different ETag for each content.

#Security
htmx allows you to define logic directly in your DOM. This has a number of advantages, the largest being Locality of Behavior, which makes your system easier to understand and maintain.

A concern with this approach, however, is security: since htmx increases the expressiveness of HTML, if a malicious user is able to inject HTML into your application, they can leverage this expressiveness of htmx to malicious ends.

#Rule 1: Escape All User Content
The first rule of HTML-based web development has always been: do not trust input from the user. You should escape all 3rd party, untrusted content that is injected into your site. This is to prevent, among other issues, XSS attacks.

There is extensive documentation on XSS and how to prevent it on the excellent OWASP Website, including a Cross Site Scripting Prevention Cheat Sheet.

The good news is that this is a very old and well understood topic, and the vast majority of server-side templating languages support automatic escaping of content to prevent just such an issue.

That being said, there are times people choose to inject HTML more dangerously, often via some sort of raw() mechanism in their templating language. This can be done for good reasons, but if the content being injected is coming from a 3rd party then it must be scrubbed, including removing attributes starting with hx- and data-hx, as well as inline <script> tags, etc.

If you are injecting raw HTML and doing your own escaping, a best practice is to whitelist the attributes and tags you allow, rather than to blacklist the ones you disallow.

#htmx Security Tools
Of course, bugs happen and developers are not perfect, so it is good to have a layered approach to security for your web application, and htmx provides tools to help secure your application as well.

Let’s take a look at them.

#hx-disable
The first tool htmx provides to help further secure your application is the hx-disable attribute. This attribute will prevent processing of all htmx attributes on a given element, and on all elements within it. So, for example, if you were including raw HTML content in a template (again, this is not recommended!) then you could place a div around the content with the hx-disable attribute on it:

<div hx-disable>
    <%= raw(user_content) %>
</div>
And htmx will not process any htmx-related attributes or features found in that content. This attribute cannot be disabled by injecting further content: if an hx-disable attribute is found anywhere in the parent hierarchy of an element, it will not be processed by htmx.

#hx-history
Another security consideration is htmx history cache. You may have pages that have sensitive data that you do not want stored in the users localStorage cache. You can omit a given page from the history cache by including the hx-history attribute anywhere on the page, and setting its value to false.

#Configuration Options
htmx also provides configuration options related to security:

htmx.config.selfRequestsOnly - if set to true, only requests to the same domain as the current document will be allowed
htmx.config.allowScriptTags - htmx will process <script> tags found in new content it loads. If you wish to disable this behavior you can set this configuration variable to false
htmx.config.historyCacheSize - can be set to 0 to avoid storing any HTML in the localStorage cache
htmx.config.allowEval - can be set to false to disable all features of htmx that rely on eval:
event filters
hx-on: attributes
hx-vals with the js: prefix
hx-headers with the js: prefix
Note that all features removed by disabling eval() can be reimplemented using your own custom javascript and the htmx event model.

#Events
If you want to allow requests to some domains beyond the current host, but not leave things totally open, you can use the htmx:validateUrl event. This event will have the request URL available in the detail.url slot, as well as a sameHost property.

You can inspect these values and, if the request is not valid, invoke preventDefault() on the event to prevent the request from being issued.

document.body.addEventListener('htmx:validateUrl', function (evt) {
  // only allow requests to the current server as well as myserver.com
  if (!evt.detail.sameHost && evt.detail.url.hostname !== "myserver.com") {
    evt.preventDefault();
  }
});
#CSP Options
Browsers also provide tools for further securing your web application. The most powerful tool available is a Content Security Policy. Using a CSP you can tell the browser to, for example, not issue requests to non-origin hosts, to not evaluate inline script tags, etc.

Here is an example CSP in a meta tag:

    <meta http-equiv="Content-Security-Policy" content="default-src 'self';">
This tells the browser “Only allow connections to the original (source) domain”. This would be redundant with the htmx.config.selfRequestsOnly, but a layered approach to security is warranted and, in fact, ideal, when dealing with application security.

A full discussion of CSPs is beyond the scope of this document, but the MDN Article provide a good jumping off point for exploring this topic.

#Configuring htmx
Htmx has some configuration options that can be accessed either programmatically or declaratively. They are listed below:

Config Variable	Info
htmx.config.historyEnabled
defaults to true, really only useful for testing
htmx.config.historyCacheSize
defaults to 10
htmx.config.refreshOnHistoryMiss
defaults to false, if set to true htmx will issue a full page refresh on history misses rather than use an AJAX request
htmx.config.defaultSwapStyle
defaults to innerHTML
htmx.config.defaultSwapDelay
defaults to 0
htmx.config.defaultSettleDelay
defaults to 20
htmx.config.includeIndicatorStyles
defaults to true (determines if the indicator styles are loaded)
htmx.config.indicatorClass
defaults to htmx-indicator
htmx.config.requestClass
defaults to htmx-request
htmx.config.addedClass
defaults to htmx-added
htmx.config.settlingClass
defaults to htmx-settling
htmx.config.swappingClass
defaults to htmx-swapping
htmx.config.allowEval
defaults to true, can be used to disable htmx’s use of eval for certain features (e.g. trigger filters)
htmx.config.allowScriptTags
defaults to true, determines if htmx will process script tags found in new content
htmx.config.inlineScriptNonce
defaults to '', meaning that no nonce will be added to inline scripts
htmx.config.attributesToSettle
defaults to ["class", "style", "width", "height"], the attributes to settle during the settling phase
htmx.config.inlineStyleNonce
defaults to '', meaning that no nonce will be added to inline styles
htmx.config.useTemplateFragments
defaults to false, HTML template tags for parsing content from the server (not IE11 compatible!)
htmx.config.wsReconnectDelay
defaults to full-jitter
htmx.config.wsBinaryType
defaults to blob, the type of binary data being received over the WebSocket connection
htmx.config.disableSelector
defaults to [hx-disable], [data-hx-disable], htmx will not process elements with this attribute on it or a parent
htmx.config.withCredentials
defaults to false, allow cross-site Access-Control requests using credentials such as cookies, authorization headers or TLS client certificates
htmx.config.timeout
defaults to 0, the number of milliseconds a request can take before automatically being terminated
htmx.config.scrollBehavior
defaults to ‘smooth’, the behavior for a boosted link on page transitions. The allowed values are auto and smooth. Smooth will smoothscroll to the top of the page while auto will behave like a vanilla link.
htmx.config.defaultFocusScroll
if the focused element should be scrolled into view, defaults to false and can be overridden using the focus-scroll swap modifier.
htmx.config.getCacheBusterParam
defaults to false, if set to true htmx will append the target element to the GET request in the format org.htmx.cache-buster=targetElementId
htmx.config.globalViewTransitions
if set to true, htmx will use the View Transition API when swapping in new content.
htmx.config.methodsThatUseUrlParams
defaults to ["get"], htmx will format requests with these methods by encoding their parameters in the URL, not the request body
htmx.config.selfRequestsOnly
defaults to true, whether to only allow AJAX requests to the same domain as the current document
htmx.config.ignoreTitle
defaults to false, if set to true htmx will not update the title of the document when a title tag is found in new content
htmx.config.disableInheritance
disables attribute inheritance in htmx, which can then be overridden by the hx-inherit attribute
htmx.config.scrollIntoViewOnBoost
defaults to true, whether or not the target of a boosted element is scrolled into the viewport. If hx-target is omitted on a boosted element, the target defaults to body, causing the page to scroll to the top.
htmx.config.triggerSpecsCache
defaults to null, the cache to store evaluated trigger specifications into, improving parsing performance at the cost of more memory usage. You may define a simple object to use a never-clearing cache, or implement your own system using a proxy object
htmx.config.allowNestedOobSwaps
defaults to true, whether to process OOB swaps on elements that are nested within the main response element. See Nested OOB Swaps.
You can set them directly in javascript, or you can use a meta tag:

<meta name="htmx-config" content='{"defaultSwapStyle":"outerHTML"}'>
"""

